\documentclass[times,specification,annotation]{itmo-student-thesis}

%% Опции пакета:
%% - specification - если есть, генерируется задание, иначе не генерируется
%% - annotation - если есть, генерируется аннотация, иначе не генерируется
%% - times - делает все шрифтом Times New Roman, собирается с помощью xelatex
%% - languages={...} - устанавливает перечень используемых языков. По умолчанию это {english,russian}.
%%                     Последний из языков определяет текст основного документа.

%% Делает запятую в формулах более интеллектуальной, например:
%% $1,5x$ будет читаться как полтора икса, а не один запятая пять иксов.
%% Однако если написать $1, 5x$, то все будет как прежде.
\usepackage{icomma}

%% Один из пакетов, позволяющий делать таблицы на всю ширину текста.
\usepackage{tabularx}

%% Данные пакеты необязательны к использованию в бакалаврских/магистерских
%% Они нужны для иллюстративных целей
%% Начало
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{filecontents}
\begin{filecontents}{bachelor-thesis.bib}
@online{ zakrzewski-def-fun-arxiv,
    year        = {2007},
    title       = {Definable functions in the simply typed lambda-calculus},
    author      = {Mateusz Zakrzewski},
    url         = {https://arxiv.org/abs/cs/0701022},
    year        = {2007},
    langid      = {english}
}

@inproceedings{ example-english,
    year        = {2015},
    booktitle   = {Proceedings of IEEE Congress on Evolutionary Computation},
    author      = {Maxim Buzdalov and Anatoly Shalyto},
    title       = {Hard Test Generation for Augmenting Path Maximum Flow 
                   Algorithms using Genetic Algorithms: Revisited},
    pages       = {2121-2128},
    langid      = {english}
}

@article{ example-russian,
    author      = {Максим Викторович Буздалов},
    title       = {Генерация тестов для олимпиадных задач по программированию 
                   с использованием генетических алгоритмов},
    journal     = {Научно-технический вестник {СПбГУ} {ИТМО}},
    number      = {2(72)},
    year        = {2011},
    pages       = {72-77},
    langid      = {russian}
}

@article{ unrestricted-jump-evco,
    author      = {Maxim Buzdalov and Benjamin Doerr and Mikhail Kever},
    title       = {The Unrestricted Black-Box Complexity of Jump Functions},
    journal     = {Evolutionary Computation},
    year        = {2016},
    note        = {Accepted for publication},
    langid      = {english}
}

\end{filecontents}
%% Конец

%% Указываем файл с библиографией.
\addbibresource{bachelor-thesis.bib}

\begin{document}


\newcommand{\todo}{\textcolor{red}{TODO}}


\studygroup{M34381}
\title{Формальная верификация классификации определимых функций в просто-типизированном лямбда-исчислении}
\author{Вихнин Фёдор Алексеевич}{Вихнин Ф.А.}
\supervisor{Корнеев Георгий Алекандрович}{Корнеев Г.А.}{к.т.н.}{доцент квалификационная категория "ординарный доцент"}
\publishyear{2023}
%% Дата выдачи задания. Можно не указывать, тогда надо будет заполнить от руки.
\startdate{01}{сентября}{2022}
%% Срок сдачи студентом работы. Можно не указывать, тогда надо будет заполнить от руки.
\finishdate{31}{мая}{2023}
%% Дата защиты. Можно не указывать, тогда надо будет заполнить от руки.
\defencedate{15}{июня}{2023}

\addconsultant{Штукенберг Д. Г.}{магистр техничеких наук, без звания}

\secretary{Штумпф С. А.}

%% Задание
%%% Техническое задание и исходные данные к работе
\technicalspec{Исходным моментом было рассмотрение статью 76-ого года о классе определимых функций в просто типизированном лямбда исчислении \cite{original-article}. Из-за краткости и неполноты представленного доказательства в ней, связанной с отсутствие доказательств некоторых важных шагов и утверждений, заданием данной ВКР было расписать и дополнить ранее упомянутые пропуски, сформулировать чётко условия теорем и их доказательства и выполнить формальную верификацию полученного результата. Необходимость в последнем вызвано тем, что из-за человеческого фактора оба доказательства могли быть утверждены верными по ошибке.}

%%% Содержание выпускной квалификационной работы (перечень подлежащих разработке вопросов)
\plannedcontents{Разработанное решение на языке Arend является полной формализацией рассмотренной статьи, с введением всех необходимых для формулирования терминов, конструкций из теории типов и математического аппарата, такого как работа с множествами, и доказательством корректности всех базовых утверждений, применимых к вышеперечисленным}

%%% Исходные материалы и пособия 
\plannedsources{\begin{enumerate}
    \item Оригинальная статья \cite{original-article};
    \item Обзорная статья с уточнением некоторых определений \cite{zakrzewski-def-fun-arxiv};
    \item Документация по использованию языка проверки доказательств Arend \cite{arend}
\end{enumerate}}

%%% Цель исследования
\researchaim{\todo}

%%% Задачи, решаемые в ВКР
\researchtargets{\begin{enumerate}
    \item \todo.
\end{enumerate}}

%%% Использование современных пакетов компьютерных программ и технологий
\addadvancedsoftware{\todo Сослаться на приложение с бумажным доказательством}{\ref{sec:tables}, Приложения~\ref{sec:app:1}, \ref{sec:app:2}}
\addadvancedsoftware{\todo Сослаться на репозиторий с решением }{Репозиторий}

%%% Краткая характеристика полученных результатов 
\researchsummary{\todo}

%%% Гранты, полученные при выполнении работы 
\researchfunding{Никакие гранты не выделялись на разработку данного решения, все было сделано в рамках написания дипломной работы}

%%% Наличие публикаций и выступлений на конференциях по теме выпускной работы
\researchpublications{Никакие публикации и выступления на конференциях не проводились}

%% Эта команда генерирует титульный лист и аннотацию.
\maketitle{Бакалавр}

%% Оглавление
\tableofcontents

\chapter*{Список Терминов}\label{chapter:terminology}%
\addcontentsline{toc}{chapter}{Cписок Терминов}

\begin{enumerate}
    \item Выражение
    \item Тип
    \item Типизация выражения
    \item Альфа-эквивалетность
    \item Бета-редукция
    \item Бета-экивалетность
    \item Свободная переменная
    \item Нормальная форма
    \item Нумерал
\end{enumerate}

%% Макрос для введения. Совместим со старым стилевиком.
\startprefacepage
Теория типов, как раздел математики, является важной частью не только интереса учёных в области компетенции но и также важный составляющий мира практического программирования, так как модели, используемые и разрабатываем в рамках данной в рамках данной дисциплины, используются в качестве архитектур ныне существующих языков программирования, технических решений либо же объясняют свойства и как-то формализуют системы, которые используются в большинстве языков программирования. В свою очередь просто типизированное лямбда исчисление является одной из самых простых, но не менее важных, моделей выражений в языках программирования. Утверждения, которые доказываются по отношению к ней, имеет большое как теоретическое, так и практическое значение. Потому есть потребность, также как любой науке, чтобы эти утверждения были заведомо корректные, особенно в случае, если выводы, которые делаются, дают какое-то большое представление об области. В свою очередь, так как все доказательства делают людьми нельзя исключать человеческий фактор. Существует множество примеров, в которых доказательства многие которые многие годы поддерживались и считались по итогу оказывались неверными и по ошибке предполагались таковыми, потому что не были рассмотрены какие-то случаи или проверяющие специалисты не обнаруживали каких-то неувязок и неточностей в оригинальном доказательстве, что могло приводить либо к появлению новых теорий и новых решений, либо же ставило под вопрос выводы всех последующих в данной области работ, так как стартовая точка оказывалась неверной. В рамках данной ВКР мы рассматриваем как раз одно из таких утверждений, заключающаяся в том, что все функции результирующие из полиномов являются полиномами. Так утверждение является достаточно важным и большим результатом в данной области очень не хотелось бы столкнуться с его некорректностью.  Доказательство оригинальной статьи нельзя считать полным, так как оно обладает некоторыми допущениями и не представляет доказательства каждого шага, а также очень коротко поясняет все свои выкладки из чего следует не точность как понимание  заложенного автором, так и подозрение вне точности представленных им рассуждений.

% В данном разделе размещается введение.


\section{Актуальность работы}
\todo
\section{Цели и задачи}
\todo

В рамках данной ВКР ставились три цели

Первая цель: изучение и проверка оригинальной статьи на корректность, её уточнение в случае необходимости и расширение новыми доказательствами. По итогу работу пришлось дополнить четырьмя новыми утверждениями доказывающими некоторые шаги в оригинальной статье или же уточняющая существующее решение.

Вторая цель: перенос всех полученных утверждений в язык проверки доказательств. То есть получение сертификации корректности всех этапов решения.

Третья цель:  расширение кодовой базы в области теории типов для дальнейшей для возможности изучения, проверки доказательств и формулирования новых утверждений сразу же пользуясь данным инструментом.

\section{Новизна работы}
\todo
\section{Практическое значение работы}
\todo

Практическим значением работы считается представление большой кодовой базы в области теории типов именно на языке аренд, как новый языка для доказательств, использующего более современные теории, по сравнению со своими предшественниками.  Что влечёт за собой не только развитие самого языка,  но и самой области формальных верификаций утверждений про языки и математические теории. В дальнейшем такое же бурное развитии данной области к развитию компиляторов, делая их более умными и способными на большие возможности в проверке полученного кода, также развитие автоматической проверки кодовых решений на баги, уязвимости и другие трудности, также вытекающие из природы написание кода людьми.

Также считаю важным отметить, что результатом данной работы является улучшение представления о возможности формализации и представления нынешней теории в области просто-типизированного лямбда исчисления и математической логики. Например, в рамках работы были рассмотрены различные способы представления выражение как таковых и их альфа-эквивалентности (содержательной одинаковости), благодаря полученному опыту были сделаны выводы об эффективности и простоте использования одних, таких как аннотация Де Брауна, и неудобности более классических, как например выражение с именными переменными.


\section{Краткое описание}
\todo
%% Начало содержательной части.
\chapter{Изучение оригинальной статьи и её дополнение}

\todo
\section{Предметная область}
\todo
\section{Описание статьи}
    Оригинальная статья посвящена классификации определимых функций в просто-типизированном лямбда исчислении.
    Первое, что делает автор, так это упоминает о не типизированном лямбда исчислении, и об определимости функций в нем, и задается
    вопросом о таковых в типизированном случае. Стоит отметить, что статья носит
    очень неформальный характер, потому о каком точно определении речь не сразу ясно,
    как будет показать в статье 2, детали описания имеют непосредственное влияние на возможные рассуждения.

    В краткой форме упоминается классической определение строго определимых функций с 
    уточнением типа равенства, который использовался. Это равенство по отношению beta редукции, 
    то есть "структурное" равенство, когда за конечное количество шагов редукции можно прийти к одной и той же форме выражения, с точностью до имен переменых (отношения альфа-эквивалентности).
    Важно отметить, что именно о структурном равенстве идет речь, а не о "вычислительном", когда гарантируется
    лишь одинаковое поведение функций на одинаковых данных (ню-экивалетность, ссылка на статью 3).

    И далее автор дает определение "расширенных полиномов" - класса функций, замкнутого по композиции:

    \begin{enumerate}
        \item сложения
        \item умножения
        \item числовых констант
        \item функции проверки на ноль ("иф-зиро"), которая принимает три аргумента и если первый 
        аргумент ноль, то возвращает второй, иначе третий
    \end{enumerate}

    Далее следует доказательство того, что только функция из такого класса,
    может быть строго определима. И теперь перейдем к рассмотрению приведенного
    доказательства и какие недостатки имел оригинал.  


\todo
\section{Анализ оригинального доказательства}
    Автор начинает рассуждает с того, что класс чистых функций (то есть функций, результат которых зависит только от переданных значений) или же замкнутых форм (то есть выражений, которые не имею свободных переменных (ссылка на определение)) замкнут по композиции. Данное утверждение не доказывается, но его можно считать очевидным.
    
    Далее автор упоминает, что все расширенные полиномы являются определимыми функциями, хоть этот факт тоже им остается не доказанным. Данное утверждение является крайне важным, так как таки образом автор подчеркивает, что множество таких функций является подмножеством определимых. И далее как он покажется зеркальное утверждение (что определимые функции являются подмножеством расширенных полиномов), то он сможет утверждать равенство данных классов. 
    
    Пользуясь тем, что в расширенных полиномах, добавлена функция иф-зиро, он говорит, что также все функции результирующие из полиномов путем добавления или удаления
    аргумента - тоже представимы, так как из-за конечности числа аргументов, можно рассмотреть конечное количество случаев с рассмотрением значений переменных на равенство нулю, что выливается в построение дерева разбора случаев из иф-зиро по каждой переменной.

    В таком случае остается убедиться лишь в том, что иных функций нет.
    
    Для этого в качестве примера, он рассматривает двуместную функцию \(t\) (для любой другой мерности, доказательство аналогичное), такую, что она определима, а значит у нее есть выражение замкнутой формы, типизируемое, как $\nu \rightarrow \nu \rightarrow \nu $, то есть как функцию от двух переменных типа \(\nu\) - типа ассоциированного с нумералами - местным представлением чисел.
    
    Взяв в качестве аргументов для данной функции числа \(n, m\) и им соответствующие выражения \(F, G\), а также рассмотрев функцию \(\alpha : \tau \rightarrow \tau\) как третий аргумент для выражения \(t\), он применяет их к выражению, берет от полученного нормальную форму и смотрит на полученных результат. Так как равенство здесь рассматривается как бета-экивалетность, то приведение к нормальной форме выражения является корректным шагом, сохраняющего справедливость утверждений об оригинальном выражении.
    
    Так как изначально бралось выражение, которое типизируется, то нормальная форма существует и она единственна, по теореме Черча-Россера (ссылка на источник).

    Рассмотрение именно нормальной формы полученного выражения, позволяет избавиться от некоторых затрудняющих случаев при рассмотрении под-термов выражения. Если быть точным: случай рассмотрения аппликации, так как в случае нормальной формы, левая часть не может быть лямбда-абстракцией, иначе бы можно было применить бета-редукцию.
    
    Далее идет разбор возможных под-термов, полученного выражения, с учетом их типизации.

    Первое, что утверждается, это то, что любой подтерм имеет один из трех типов:

    \begin{enumerate}
        \item \(\tau\)
        \item \(\tau \rightarrow \tau\)
        \item \(\nu = (\tau \rightarrow \tau) \rightarrow \tau \rightarrow \tau\)
    \end{enumerate}

    Данное заявление никак не доказывается, и является первым таким утверждением, крайне мала очевидность правдивости которых. В дальнейшем будет рассмотрена данная проблема. 

    Далее утверждается, тоже бездоказательно, что единственным подтермами типа \(\nu\) являются константы \(F, G\). И разбираются возможные случаи подтермов, которые могут иметь тип \(\tau \rightarrow \tau\).

    Опуская неочевидность существования только таких случаев, автор приближает доказательство к концу, воспользовавшись математической индукцией по структуре выражения. А точнее, он хочет показать, что любой подтерм данного выражения с типом \(\tau \rightarrow \tau\) может быть средуцирован до выражения вида \(\lambda y . \alpha^{P(n,\ m)} z\), где  \(P\) - функция из класса расширенных полиномов, а \(z\) - любая переменная. В дальнейшем такое выражение будет называться "константным полиномом". Показывает он это тем, что рассматривает каждый ранее указанный разбор такого выражения как шаг индукции, за базу взяв случай равенства выражения с ранее упомянутой \(\alpha\). 

    По итогу доказав то, что любой такой подтерм является константным полиномом, он, ссылаясь на то, что искомое выражение \(t F G \alpha\) тоже имеет такой тип, получает, что функция редуцируется в \(\lambda y. \alpha^{P(n, m)}y \) - что является нумералом от \(P(n, m)\), а значит полученная функция - расширенный полином.   


\todo
\subsection{Рассмотрение пропущенных шагов доказательства}

Как было указано в предыдущей главе, автор пользуется перечнем недоказанных им и неочевидных также утверждений, на основе которых и строит свои рассуждения, и без которых доказательство не представляется возможным, а именно:

\begin{enumerate}
    \item Любой подтерм обладает одним из перечисленных типов: \(\tau, \tau \rightarrow \tau, \nu \)
    \item Любой подтерм типа \(\nu\) - это \(F\) или \(G\).
    \item Любой подтерм типа \(\tau \rightarrow \tau\) - это либо \begin{enumerate}
        \item \(\alpha\)
        \item \(F s\) или \(G s\), где \(s\) - также типизируется как \(\tau \rightarrow \tau\)
        \item \(\lambda y. s_1 (s_2 (\cdots s_k (z) \cdots))\), аналогично \(\forall i.\ s_i\) имеет тип \(\tau \rightarrow \tau\)
    \end{enumerate}
\end{enumerate}

Перечисленные шаги не являются выводами из каких-то теорем или не являются результатами каких-то работ, по-крайней мере нет ни единого упоминания о таковых, а с учетом специфики области и новизны такого класса функций, на момент написания работы, и, следовательно, рассуждений о структуре выражений в таком ключе и с такими типами, то закономерно заключить, что все перечисленные утверждения, особенно с учетом их содержательности, были оставлены автором непроверенными и требуют быть доказанными, дабы можно было считать искомое доказательство верным.


тут странно.
\todo
\subsection{Необходимость в ведении новых утверждений}
\todo

\chapterconclusion

В данной главе была рассмотрена оригинальная статья, значимость ее результата для области и досконально разобрано предлагаемое доказательство. 

В ходе рассмотрения доказательства было выявлено несколько мест, где автор формулировал для дальнейшего использования утверждения, доказательство которых не предоставлялось ни самим автором, ни в качестве ссылки на другие работы в данной области. Именно данный нюанс и побудил рассмотрение доказательство подробнее, дополнить его недостающим доказательствами и утверждениями и произвести процесс полной верификации полученного результата.

%% Так помечается начало обзора.
\startrelatedwork
% Пример ссылок в рамках обзора: \cite{zakrzewski-def-fun-arxiv, original-article}.
%% Так помечается конец обзора.
\finishrelatedwork
% Вне обзора:~\cite{bellman}.

% \section{Таблицы}\label{sec:tables}

% В качестве примера таблицы приведена таблица~\ref{tab1}.

% \begin{table}[!h]
% \caption{Таблица умножения (фрагмент)}\label{tab1}
% \centering
% \begin{tabular}{|*{18}{c|}}\hline
% -- & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
% 1  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
% 2  & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 16 & 18 & 20 & 22 & 24 & 26 & 28 & 30 & 32 & 34 \\\hline
% 3  & 3 & 6 & 9 & 12 & 15 & 18 & 21 & 24 & 27 & 30 & 33 & 36 & 39 & 42 & 45 & 48 & 51 \\\hline
% 4  & 4 & 8 & 12 & 16 & 20 & 24 & 28 & 32 & 36 & 40 & 44 & 48 & 52 & 56 & 60 & 64 & 68 \\\hline
% \end{tabular}
% \end{table}

% Есть еще такое окружение \texttt{tabularx}, его можно аккуратно растянуть на всю страницу.
% Приведем пример (таблица~\ref{tab2}).

% \begin{table}[!h]
% \caption{Таблица умножения с помощью \texttt{tabularx} (фрагмент)}\label{tab2}
% \centering
% \begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
% -- & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
% 1  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
% 2  & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 16 & 18 & 20 & 22 & 24 & 26 & 28 & 30 & 32 & 34 \\\hline
% 3  & 3 & 6 & 9 & 12 & 15 & 18 & 21 & 24 & 27 & 30 & 33 & 36 & 39 & 42 & 45 & 48 & 51 \\\hline
% 4  & 4 & 8 & 12 & 16 & 20 & 24 & 28 & 32 & 36 & 40 & 44 & 48 & 52 & 56 & 60 & 64 & 68 \\\hline
% \end{tabularx}
% \end{table}

% Пример рисунка (c помощью \texttt{TikZ}) приведен на рисунке~\ref{fig1}. Под \texttt{pdflatex} можно также
% использовать \texttt{*.jpg}, \texttt{*.png} и даже \texttt{*.pdf}, под \texttt{latex} можно использовать
% Metapost. Последний можно использовать и под \texttt{pdflatex}, для чего в стилевике продекларированы
% номера картинок от~1 до~20.

% \begin{figure}[!h]
% \caption{Пример рисунка}\label{fig1}
% \centering
% \begin{tikzpicture}[scale=0.7]
% \draw[thick,->] (0,0)--(3.5,0);
% \draw[thick,->] (0,0)--(0,3.5);
% \draw[very thick, red] (0,0)--(3,3);
% \draw[dashed] (3,0)--(3,3);
% \draw[dashed] (1.5,0)--(1.5,1.5);
% \end{tikzpicture}
% \end{figure}

% В работах студентов кафедры <<Компьютерные технологии>> часто встречаются листинги. Листинги бывают
% двух основных видов~--- исходный код и псевдокод. Первый оформляется с помощью окружения \texttt{lstlisting}
% из пакета \texttt{listings}, который уже включается в стилевике и немного настроен. Пример Hello World на Java
% приведен на листинге~\ref{lst1}. Пример большого листинга~--- в приложении (листинг~\ref{lstX}).

% \begin{lstlisting}[float=!h,caption={Пример исходного кода на Java},label={lst1}]
% public class HelloWorld {
%     public static void main(String[] args) {
%         System.out.println("Hello, world!");
%     }
% }
% \end{lstlisting}

% Псевдокод можно оформлять с помощью разных пакетов. В данном стилевике включается пакет \texttt{algorithmicx}.
% Сам по себе он не генерирует флоатов, поэтому для них используется пакет \texttt{algorithm}.
% Пример их совместного использования приведен на листинге~\ref{lst2}.

% \begin{algorithm}[!h]
% \caption{Пример псевдокода}\label{lst2}
% \begin{algorithmic}
% 	\Function{IsPrime}{$N$}
% 		\For{$t \gets [2; \lfloor\sqrt{N}\rfloor]$}
% 			\If{$N \bmod t = 0$}
% 				\State\Return \textsc{false}
% 			\EndIf
% 		\EndFor
% 		\State\Return \textsc{true}
% 	\EndFunction
% \end{algorithmic}
% \end{algorithm}

% Наконец, листинги из \texttt{listings} тоже можно подвешивать с помощью \texttt{algorithm},
% пример на листинге~\ref{lst3}.

% \begin{algorithm}[!h]
% \caption{Исходный код и флоат \texttt{algorithm}}\label{lst3}
% \begin{lstlisting}
% public class HelloWorld {
%     public static void main(String[] args) {
%         System.out.println("Hello, world!");
%     }
% }
% \end{lstlisting}
% \end{algorithm}

\chapter{Методология решения}
\todo
\section{Анализ необходимой теоретической базы}
\todo
\section{Этапы решения}
\todo

\chapterconclusion

\chapter{Формулирования доказательства на языке Arend}
\todo
\section{Мотивация выбора данного языка}
\todo
\section{Сложности во время реализации}
\todo
\subsection{Альфа эквивалентность}
\todo
\subsection{Операции над множествами}
\todo
\section{Практическое применение}
\todo
% Листинг~\ref{lst4} должен иметь номер 4.

% \begin{algorithm}[!h]
% \caption{Исходный код и флоат \texttt{algorithm}}\label{lst4}
% \begin{lstlisting}
% public class HelloWorld {
%     public static void main(String[] args) {
%         System.out.println("Hello, world!");
%     }
% }
% \end{lstlisting}
% \end{algorithm}

% Рисунок~\ref{fig2} должен иметь номер 2.

% \begin{figure}[!h]
% \caption{Пример рисунка}\label{fig2}
% \centering
% \begin{tikzpicture}[scale=0.7]
% \draw[thick,->] (0,0)--(3.5,0);
% \draw[thick,->] (0,0)--(0,3.5);
% \draw[very thick, red] (0,0)--(3,3);
% \draw[dashed] (3,0)--(3,3);
% \draw[dashed] (1.5,0)--(1.5,1.5);
% \end{tikzpicture}
% \end{figure}

% Таблица~\ref{tab3} должна иметь номер 3.

% \begin{table}[!h]
% \caption{Таблица умножения с помощью \texttt{tabularx} (фрагмент)}\label{tab3}
% \centering
% \begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
% -- & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
% 1  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
% 2  & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 16 & 18 & 20 & 22 & 24 & 26 & 28 & 30 & 32 & 34 \\\hline
% 3  & 3 & 6 & 9 & 12 & 15 & 18 & 21 & 24 & 27 & 30 & 33 & 36 & 39 & 42 & 45 & 48 & 51 \\\hline
% 4  & 4 & 8 & 12 & 16 & 20 & 24 & 28 & 32 & 36 & 40 & 44 & 48 & 52 & 56 & 60 & 64 & 68 \\\hline
% \end{tabularx}
% \end{table}

\chapterconclusion

В конце каждой главы желательно делать выводы. Вывод по данной главе~--- нумерация работает корректно, ура!

%% Макрос для заключения. Совместим со старым стилевиком.
\startconclusionpage

В данном разделе размещается заключение.

\printmainbibliography

%% После этой команды chapter будет генерировать приложения, нумерованные русскими буквами.
%% \startappendices из старого стилевика будет делать то же самое
\appendix

\chapter{Математические выкладки}\label{sec:app:1}

% В приложениях рисунки, таблицы и другие подобные элементы нумеруются по приложениям с соответствующим префиксом. Проверим это.

% Листинг~\ref{lst4:apx} должен иметь номер А.1.

% \begin{algorithm}[!h]
% \caption{Исходный код и флоат \texttt{algorithm}}\label{lst4:apx}
% \begin{lstlisting}
% public class HelloWorld {
%     public static void main(String[] args) {
%         System.out.println("Hello, world!");
%     }
% }
% \end{lstlisting}
% \end{algorithm}

% Рисунок~\ref{fig2:apx} должен иметь номер A.1.

% \begin{figure}[!h]
% \caption{Пример рисунка}\label{fig2:apx}
% \centering
% \begin{tikzpicture}[scale=0.7]
% \draw[thick,->] (0,0)--(3.5,0);
% \draw[thick,->] (0,0)--(0,3.5);
% \draw[very thick, red] (0,0)--(3,3);
% \draw[dashed] (3,0)--(3,3);
% \draw[dashed] (1.5,0)--(1.5,1.5);
% \end{tikzpicture}
% \end{figure}

% Таблица~\ref{tab3:apx} должна иметь номер A.1.

% \begin{table}[!h]
% \caption{Таблица умножения с помощью \texttt{tabularx} (фрагмент)}\label{tab3:apx}
% \centering
% \begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
% -- & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
% 1  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
% 2  & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 16 & 18 & 20 & 22 & 24 & 26 & 28 & 30 & 32 & 34 \\\hline
% 3  & 3 & 6 & 9 & 12 & 15 & 18 & 21 & 24 & 27 & 30 & 33 & 36 & 39 & 42 & 45 & 48 & 51 \\\hline
% 4  & 4 & 8 & 12 & 16 & 20 & 24 & 28 & 32 & 36 & 40 & 44 & 48 & 52 & 56 & 60 & 64 & 68 \\\hline
% \end{tabularx}
% \end{table}

% Заодно проверим нумерованные и ненумерованные перечисления. Ненумерованные:
% \begin{itemize}
%     \item пункт А;
%     \item пункт Б;
%     \item пункт В.
% \end{itemize}

% Нумерованные списки нескольких уровней:
% \begin{enumerate}
%     \item первый элемент;
%     \item второй элемент с подэлементами:
%     \begin{enumerate}
%         \item первый подэлемент;
%         \item второй подэлемент;
%         \item третий подэлемент.
%     \end{enumerate}
%     \item третий элемент;
%     \item четвертый элемент;
%     \item пятый элемент;
%     \item шестой элемент;
%     \item седьмой элемент;
%     \item восьмой элемент;
%     \item девятый элемент;
%     \item десятый элемент.
% \end{enumerate}

\chapter{Репозиторий с кодовым решением}\label{sec:app:2}

% Проверим на примере таблиц, что нумерация в приложениях~--- по приложениям.
% Таблица~\ref{tab3:apx2} должна иметь номер Б.1.

% \begin{table}[!h]
% \caption{Таблица умножения с помощью \texttt{tabularx} (фрагмент)}\label{tab3:apx2}
% \centering
% \begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
% -- & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
% 1  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
% 2  & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 16 & 18 & 20 & 22 & 24 & 26 & 28 & 30 & 32 & 34 \\\hline
% 3  & 3 & 6 & 9 & 12 & 15 & 18 & 21 & 24 & 27 & 30 & 33 & 36 & 39 & 42 & 45 & 48 & 51 \\\hline
% 4  & 4 & 8 & 12 & 16 & 20 & 24 & 28 & 32 & 36 & 40 & 44 & 48 & 52 & 56 & 60 & 64 & 68 \\\hline
% \end{tabularx}
% \end{table}

% \begin{lstlisting}[caption={Пример большого листинга},label={lstX}]
% import java.util.*;

% public class Example {
%     static int[] restoreOutgoing(int[] g, int[] outgoing,
%                                  int vertex, int mask) {
%         int[] rv = new int[1 + Integer.bitCount(mask)];
%         int n = g.length;
%         int current = rv.length - 1;
%         while (true) {
%             rv[current] = vertex;
%             if (current == 0) {
%                 if (vertex != 0) {
%                     throw new AssertionError();
%                 }
%                 return rv;
%             }
%             mask ^= 1 << (vertex - 1);
%             int prevMask = outgoing[mask] & g[vertex];
%             if (prevMask == 0) {
%                 throw new AssertionError();
%             }
%             vertex = Integer.numberOfTrailingZeros(prevMask);
%             --current;
%         }
%     }

%     static int[] restoreIncoming(int[] g, int[] incoming,
%                                  int vertex, int mask) {
%         int[] rv = new int[1 + Integer.bitCount(mask)];
%         int n = g.length;
%         int current = 0;
%         while (true) {
%             rv[current] = vertex;
%             if (current == rv.length - 1) {
%                 if (vertex != 0) {
%                     throw new AssertionError();
%                 }
%                 return rv;
%             }
%             mask ^= 1 << (vertex - 1);
%             int nextMask = incoming[mask] & g[vertex];
%             if (nextMask == 0) {
%                 throw new AssertionError();
%             }
%             vertex = Integer.numberOfTrailingZeros(nextMask);
%             ++current;
%         }
%     }
% }
% \end{lstlisting}

\end{document}
