\import Arith.Int
\import Arith.Nat
\import Data.Bool
\import Function.Meta ($)
\import Logic
\import Paths
\import Paths.Meta
\import Set
\open Nat


\data Type_ : \Set
  | Base Nat
  | \infixr 6 ~> Type_ Type_

\data Expr_
  | c Nat
  | v Nat -- layer diff
  | \fixr 2 l Expr_
  | \infixl 6 @ Expr_ Expr_

\instance TDecSet : DecSet Type_
  | decideEq => decideEqImpl
  \where {
    \func decideEqImpl (x y : Type_) : Dec (x = y) \elim x, y
      | Base n, Base n1 => \case NatSemiring.decideEq n n1 \with {
        | yes n=n1 => yes (pmap Base n=n1)
        | no n/=n1 => no (\lam p => n/=n1 (rmBase {n} {n1} p))
      }
      | Base n, s ~> s1 => no (\lam p => suc/=0 {0} (inv (pmap conNo p)))
      | s ~> s1, Base n => no (\lam p => suc/=0 {0} (pmap conNo p))
      | a1 ~> b1, a2 ~> b2 =>
        \let
          | a1?=a2 => decideEqImpl a1 a2
          | b1?=b2 => decideEqImpl b1 b2
        \in \case a1?=a2, b1?=b2 \with {
          | yes a1=a2, yes b1=b2 => yes (pmap2 (~>) a1=a2 b1=b2)
          | yes a1=a2, no b1/=b2 => no (\lam p => b1/=b2 (rmFunc p).2)
          | no a1/=a2, _ => no (\lam p => a1/=a2 (rmFunc p).1)
        }

    \func rmBase {n n1 : Nat} (p : Base n = Base n1) : n = n1 =>
      \let
        | df => \lam (x : Type_) => \case x \return Nat \with {
          | Base i => i
          | s ~> s1 => 0
        } \in pmap df p

    \func rmFunc {a1 a2 b1 b2 : Type_} (p : a1 ~> b1 = a2 ~> b2) : \Sigma (a1 = a2) (b1 = b2) =>
      \let
        | df => \lam (x : Type_) => \case x \return \Sigma Type_ Type_ \with {
          | Base n => (Base 0, Base 0)
          | s ~> s1 => (s, s1)
        } \in (pmap (\lam t => (df t).1) p, pmap (\lam t => (df t).2) p)

    \func conNo (x : Type_) : Nat \elim x
      | Base n => 0
      | x1 ~> x2 => 1
  }

\data Context_
  | empty
  | with (\Sigma Int Type_) Context_
  \where {
    \func rm-assump (assumption : \Sigma Int Type_) (context : Context_) : Context_ \elim assumption, context
      | (n,s), with _x _context => if (_x.1 == n) _context (with _x (rm-assump (n, s) _context))
      | (n,s), empty => empty

    \func update-assump (newAssumption : \Sigma Int Type_) (context : Context_) : Context_ \elim newAssumption, context
      | (n,s), with (n', s') _context => with (n', if (n' == n) s s') (if (n' == n) _context (update-assump (n, s)  _context))
      | (n,s), empty => with (n, s) empty

    \func add-assump (newAssumption : \Sigma Int Type_) (context : Context_) : Context_ \elim newAssumption, context
      | (n,s), with _x _context => with _x (if (_x.1 == n) _context (add-assump (n, s)  _context))
      | (n,s), empty => with (n, s) empty

    \func var-in-context (var : Int) (c : Context_) : Bool \elim c
      | empty => false
      | with (i, _) c' => if (i == var) true (var-in-context var c')

    \func typed-var-in-context (var-with-type : \Sigma Int Type_) (c : Context_) : Bool \elim c
      | empty => false
      | with (i, t) c' =>
        if (i == var-with-type.1)
            (t TDecSet.== var-with-type.2)
            (typed-var-in-context var-with-type c')
  }

\data TypedExpr_ (e : Expr_) (t : Type_) (h : Nat) (c : Context_) \elim e, t
  | (c _), t => t-con
  | (v i), t => t-var (i-exist : Context_.typed-var-in-context (h - suc i, t) c = true)
  | (l B), tx ~> tB => t-lam (B-typed : TypedExpr_ B tB (suc h) (Context_.update-assump (h, tx) c))
  | P @ Q, tr => t-app (tq : Type_) (P-typed : TypedExpr_ P (tq ~> tr) h c) (Q-typed : TypedExpr_ Q tq h c)


\data AlphaEq (e1 e2 : Expr_) \elim e1, e2
  | c i, c j => same-con (i = j)
  | v i, v j => save-var (i = j)
  | P1 @ Q1, P2 @ Q2 => same-app (AlphaEq P1 Q1) (AlphaEq P2 Q2)
  | l B1, l B2 => same-lam (AlphaEq B1 B2)

\data BetaRed (e1 e2 : Expr_) \elim e1, e2
  | P1 @ Q1, P2 @ Q2 => bred-app-right (P1 = P2) (BetaRed Q1 Q2)
  | P1 @ Q1, P2 @ Q2 => bred-app-left (BetaRed P1 P2) (Q1 = Q2)
  | (l P) @ Q, s => bred-repl (s = apply_ P Q)
  | l B1, l B2 => beta-lam (BetaRed B1 B2)

\data BetaEq (e1 e2 : Expr_)
  | b-eq-eq (e1 = e2)
  | b-eq-red (BetaRed e1 e2)
  | b-eq-inv-red (BetaRed e2 e1)
  | b-eq-chain (tmp : Expr_) (BetaEq e1 tmp) (BetaEq tmp e2)
  \where {
    \func sym {e1 e2 : Expr_} (p : BetaEq e1 e2) : BetaEq e2 e1 \elim p
      | b-eq-eq p => b-eq-eq (inv p)
      | b-eq-red b => b-eq-inv-red b
      | b-eq-inv-red b => b-eq-red b
      | b-eq-chain tmp p1 p2 => b-eq-chain tmp (sym p2) (sym p1)

    \func app-save-eq-left {P1 P2 Q : Expr_} (b-p : BetaEq P1 P2) : BetaEq (P1 @ Q) (P2 @ Q) \elim b-p
      | b-eq-eq p => b-eq-eq (pmap2 (@) p idp)
      | b-eq-red b => b-eq-red (bred-app-left b idp)
      | b-eq-inv-red b => b-eq-inv-red (bred-app-left b idp)
      | b-eq-chain tmp b-p1 b-p2 => b-eq-chain (tmp @ Q) (app-save-eq-left b-p1) (app-save-eq-left b-p2)

    \func app-save-eq-right {P Q1 Q2 : Expr_} (b-q : BetaEq Q1 Q2) : BetaEq (P @ Q1) (P @ Q2) \elim b-q
      | b-eq-eq p => b-eq-eq (pmap2 (@) idp p)
      | b-eq-red b => b-eq-red (bred-app-right idp b)
      | b-eq-inv-red b => b-eq-inv-red (bred-app-right idp b)
      | b-eq-chain tmp b-p1 b-p2 => b-eq-chain (P @ tmp) (app-save-eq-right b-p1) (app-save-eq-right b-p2)
  }


\func isFree (n cur_h : Nat) => nat_<=-dec.nat_<=_Bool cur_h n

-- (l B) A = B[0=A]
\func apply_ (B A : Expr_) : Expr_ => apply''_ B A 0
  \where {
    \func apply''_ (B A : Expr_) (cur_h : Nat) : Expr_ \elim B
      | c n => c n
      | v 0 => if (0 == cur_h) (shift+dh A cur_h 0) (v 0)
      | v (suc n) => if (suc n == cur_h) (shift+dh A cur_h 0) (if (isFree (suc n) cur_h) (v n) (v (suc n)))
      | l B => l (apply''_ B A (suc cur_h))
      | B1 @ B2 => apply''_ B1 A cur_h @ apply''_ B2 A cur_h

    \func shift+dh (e : Expr_) (dh : Nat) (cur_h : Nat) : Expr_ \elim e
      | c n => c n
      | v n => if (isFree n cur_h) (v (n + dh)) (v n)
      | l e => l (shift+dh e dh (suc cur_h))
      | e1 @ e2 => shift+dh e1 dh cur_h @ shift+dh e2 dh cur_h

    \func shift-0=id {e : Expr_} {cur-h : Nat} : shift+dh e 0 cur-h = e \elim e
      | c n => idp
      | v n => \case isFree n cur-h \as d \return if d (v n) (v n) = v n \with {
        | false => idp
        | true => idp
      }
      | l e => pmap l shift-0=id
      | e1 @ e2 => pmap2 (@) shift-0=id shift-0=id

    \func trivial-apply {x : Expr_} : x = apply_ (v 0) x =>
      (
        rewrite apply_.shift-0=id idp
        : x = if (0 NatSemiring.== 0) (apply_.shift+dh x 0 0) (v 0)
      )

    \func trivial/=0-apply {x : Expr_} {n : Nat} : v n = apply_ (v (suc n)) x =>
        (
          idp
          : v n = if (suc n == 0) (apply_.shift+dh x 0 0) (if (isFree (suc n) 0) (v n) (v (suc n)))
        )
  }

\func test : apply_ (l $ v 3 @ v 1 @ (l $ v 0 @ v 2)) (l $ v 4 @ v 0) = (l $ v 2 @ (l $ v 5 @ v 0) @ (l $ v 0 @ (l $ v 6 @ v 0))) =>
  idp

\func test2 : (l $ l $ v 1) /= (l $ l $ v 0) => \lam p => suc/=0 (pmap (\lam x => \case x \with { | (l (l (v i))) => i | _ => 2}) p)

\func rep2 (n : Nat) (f : Expr_) (x : Expr_) : Expr_ \elim n
  | 0 => x
  | suc n => f @ rep2 n f x
  \where {
    \func replace-args-left {n : Nat} {f x x0 : Expr_} : rep2 n (apply_ f x0) (apply_ x x0) = apply_ (rep2 n f x) x0 \elim n
      | 0 => idp
      | suc n => pmap2 (@) idp replace-args-left

    \func save-beta-eq {f : Expr_} {x1 x2 : Expr_} (n : Nat) (bx1-x2 : BetaEq x1 x2) : BetaEq (rep2 n f x1) (rep2 n f x2) \elim n
      | 0 => bx1-x2
      | suc n => BetaEq.app-save-eq-right (save-beta-eq n bx1-x2)
  }

\func test3 (n m : Nat) : rep2 n (v 1) (rep2 m (v 1) (v 0)) = rep2 (n + m) (v 1) (v 0) \elim n, m
  | 0, 0 => idp
  | 0, suc m => idp
  | suc n, 0 => idp
  | suc n, suc m => pmap (v 1 @) (test3 n (suc m))

\func test4 (n m : Nat) : BetaEq (rep2 n (l $ rep2 m (v 2) (v 0)) (v 0)) (rep2 (n * m) (v 1) (v 0))
  | 0, 0 => b-eq-eq idp
  | 0, suc m => rewrite NatSemiring.zro_*-left (b-eq-eq idp)
  | suc n, 0 => b-eq-chain (rep2 n (l (v 0)) (v 0)) (b-eq-red (bred-repl apply_.trivial-apply)) (test4-lemma n)
  | suc n, suc m =>
    \let
      | r => rep2.replace-args-left {m} {v 2} {v 0} {rep2 n (l (v 2 @ rep2 m (v 2) (v 0))) (v 0)}
      | r2 => test3 m (n * m + n)
    \in
    b-eq-chain (v 1 @ rep2 m (v 1) (rep2 n (l (v 2 @ rep2 m (v 2) (v 0))) (v 0)))
        (b-eq-red (bred-repl (pmap (v 1 @) (pmap2 (rep2 m) idp apply_.trivial-apply *> r))))
        (b-eq-chain (rep2 (suc m) (v 1) (rep2 (n * suc m) (v 1) (v 0)))
            (BetaEq.app-save-eq-right (rep2.save-beta-eq m (test4 n (suc m))))
            (b-eq-eq (pmap (v 1 @) (r2 *> pmap (\lam x => rep2 x (v 1) (v 0)) (repeat-linear-*-math-lemma m n))))
        )
  \where {
    \func test4-lemma (n : Nat) : BetaEq (rep2 n (l (v 0)) (v 0)) (v 0) \elim n
      | 0 => b-eq-eq idp
      | suc n => b-eq-chain (rep2 n (l (v 0)) (v 0)) (b-eq-red (bred-repl apply_.trivial-apply)) (test4-lemma n)

    \func repeat-linear-*-math-lemma (m n : Nat) : m Nat.+ (n Nat.* m Nat.+ n) = suc n Nat.* m Nat.+ n =>
      rewrite (inv NatSemiring.+-assoc)
          (rewrite (NatSemiring.+-comm {m} {n * m})
              (rewrite
                  (rewrite (NatSemiring.*-comm {suc n} {m})
                      (rewrite (NatSemiring.*-comm {n} {m}) idp) : suc n * m = n * m + m)
                  idp
              )
          )
  }

\func a => Type_.Base 0
\func b => Type_.Base 1
\func d => Type_.Base 2

\func test5 : TypedExpr_ (l $ l $ v 1 @ v 0) ((a ~> a) ~> a ~> a) 0 Context_.empty => t-lam (t-lam (t-app a (t-var idp) (t-var idp)))
\func test6 : TypedExpr_ (l $ l $ v 2 @ v 0) ((d ~> d) ~> b ~> a) 0 (with (-1, b ~> a) Context_.empty) => t-lam (t-lam (t-app b (t-var idp) (t-var idp)))