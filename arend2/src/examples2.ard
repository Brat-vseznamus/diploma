\import Arith.Nat
\import Data.Bool
\import Function.Meta ($)
\import Logic
\import Paths
\import Paths.Meta
\import Set

\open Nat

\data Expr_
  | c Nat
  | v Nat -- layer diff
  | \fixr 2 l Expr_
  | \infixl 6 @ Expr_ Expr_

\data AlphaEq (e1 e2 : Expr_) \elim e1, e2
  | c i, c j => same-con (i = j)
  | v i, v j => save-var (i = j)
  | P1 @ Q1, P2 @ Q2 => same-app (AlphaEq P1 Q1) (AlphaEq P2 Q2)
  | l B1, l B2 => same-lam (AlphaEq B1 B2)


\func isFree (n cur_h : Nat) => nat_<=-dec.nat_<=_Bool cur_h n

-- (l B) A = B[0=A]
\func apply_ (B A : Expr_) : Expr_ => apply''_ B A 0
  \where {
    \func apply''_ (B A : Expr_) (cur_h : Nat) : Expr_ \elim B
      | c n => c n
      | v 0 => if (0 == cur_h) (shift+dh A cur_h 0) (v 0)
      | v (suc n) => if (suc n == cur_h) (shift+dh A cur_h 0) (if (isFree (suc n) cur_h) (v n) (v (suc n)))
      | l B => l (apply''_ B A (suc cur_h))
      | B1 @ B2 => apply''_ B1 A cur_h @ apply''_ B2 A cur_h

    \func shift+dh (e : Expr_) (dh : Nat) (cur_h : Nat) : Expr_ \elim e
      | c n => c n
      | v n => if (isFree n cur_h) (v (n + dh)) (v n)
      | l e => l (shift+dh e dh (suc cur_h))
      | e1 @ e2 => shift+dh e1 dh cur_h @ shift+dh e2 dh cur_h

    \func shift-0=id {e : Expr_} {cur-h : Nat} : shift+dh e 0 cur-h = e \elim e
      | c n => idp
      | v n => \case isFree n cur-h \as d \return if d (v n) (v n) = v n \with {
        | false => idp
        | true => idp
      }
      | l e => pmap l shift-0=id
      | e1 @ e2 => pmap2 (@) shift-0=id shift-0=id

    \func trivial-apply {x : Expr_} : x = apply_ (v 0) x =>
      (
        rewrite apply_.shift-0=id idp
        : x = if (0 NatSemiring.== 0) (apply_.shift+dh x 0 0) (v 0)
      )

    \func trivial/=0-apply {x : Expr_} {n : Nat} : v n = apply_ (v (suc n)) x =>
        (
          idp
          : v n = if (suc n == 0) (apply_.shift+dh x 0 0) (if (isFree (suc n) 0) (v n) (v (suc n)))
        )
  }

\func test : apply_ (l $ v 3 @ v 1 @ (l $ v 0 @ v 2)) (l $ v 4 @ v 0) = (l $ v 2 @ (l $ v 5 @ v 0) @ (l $ v 0 @ (l $ v 6 @ v 0))) =>
  idp

\func test2 : (l $ l $ v 1) /= (l $ l $ v 0) => \lam p => suc/=0 (pmap (\lam x => \case x \with { | (l (l (v i))) => i | _ => 2}) p)

\func rep2 (n : Nat) (f : Expr_) (x : Expr_) : Expr_ \elim n
  | 0 => x
  | suc n => f @ rep2 n f x
  \where {
    \func replace-args-left {n : Nat} {f x x0 : Expr_} : rep2 n (apply_ f x0) (apply_ x x0) = apply_ (rep2 n f x) x0 \elim n
      | 0 => idp
      | suc n => pmap2 (@) idp replace-args-left

    \func save-beta-eq {f : Expr_} {x1 x2 : Expr_} (n : Nat) (bx1-x2 : b-eq x1 x2) : b-eq (rep2 n f x1) (rep2 n f x2) \elim n
      | 0 => bx1-x2
      | suc n => {?}
  }

\data b-red (e1 e2 : Expr_) \elim e1, e2
  | P1 @ Q1, P2 @ Q2 => bred-app-right (P1 = P2) (b-red Q1 Q2)
  | P1 @ Q1, P2 @ Q2 => bred-app-left (b-red P1 P2) (Q1 = Q2)
  | (l P) @ Q, s => bred-repl (s = apply_ P Q)
  | l B1, l B2 => beta-lam (b-red B1 B2)

\data b-eq (e1 e2 : Expr_)
  | b-eq-eq (e1 = e2)
  | b-eq-red (b-red e1 e2)
  | b-eq-inv-red (b-red e2 e1)
  | b-eq-chain (tmp : Expr_) (b-eq e1 tmp) (b-eq tmp e2)
  \where {
    \func sym {e1 e2 : Expr_} (p : b-eq e1 e2) : b-eq e2 e1 \elim p
      | b-eq-eq p => b-eq-eq (inv p)
      | b-eq-red b => b-eq-inv-red b
      | b-eq-inv-red b => b-eq-red b
      | b-eq-chain tmp p1 p2 => b-eq-chain tmp (sym p2) (sym p1)

    \func app-save-eq-left {P1 P2 Q : Expr_} (b-p : b-eq P1 P2) : b-eq (P1 @ Q) (P2 @ Q) \elim b-p
      | b-eq-eq p => b-eq-eq (pmap2 (@) p idp)
      | b-eq-red b => b-eq-red (bred-app-left b idp)
      | b-eq-inv-red b => b-eq-inv-red (bred-app-left b idp)
      | b-eq-chain tmp b-p1 b-p2 => b-eq-chain (tmp @ Q) (app-save-eq-left b-p1) (app-save-eq-left b-p2)

    \func app-save-eq-right {P Q1 Q2 : Expr_} (b-q : b-eq Q1 Q2) : b-eq (P @ Q1) (P @ Q2) \elim b-q
      | b-eq-eq p => b-eq-eq (pmap2 (@) idp p)
      | b-eq-red b => b-eq-red (bred-app-right idp b)
      | b-eq-inv-red b => b-eq-inv-red (bred-app-right idp b)
      | b-eq-chain tmp b-p1 b-p2 => b-eq-chain (P @ tmp) (app-save-eq-right b-p1) (app-save-eq-right b-p2)
  }


\func test3 (n m : Nat) : rep2 n (v 1) (rep2 m (v 1) (v 0)) = rep2 (n + m) (v 1) (v 0) \elim n, m
  | 0, 0 => idp
  | 0, suc m => idp
  | suc n, 0 => idp
  | suc n, suc m => pmap (v 1 @) (test3 n (suc m))

\func test4 (n m : Nat) : b-eq (rep2 n (l $ rep2 m (v 2) (v 0)) (v 0)) (rep2 (n * m) (v 1) (v 0))
  | 0, 0 => b-eq-eq idp
  | 0, suc m => rewrite NatSemiring.zro_*-left (b-eq-eq idp)
  | suc n, 0 => b-eq-chain (rep2 n (l (v 0)) (v 0)) (b-eq-red (bred-repl apply_.trivial-apply)) (test4-lemma n)
  | suc n, suc m =>
    \let
      | r => rep2.replace-args-left {m} {v 2} {v 0} {rep2 n (l (v 2 @ rep2 m (v 2) (v 0))) (v 0)}
      | r2 => test3 m (n * m + n)
    \in
    b-eq-chain (v 1 @ rep2 m (v 1) (rep2 n (l (v 2 @ rep2 m (v 2) (v 0))) (v 0)))
        (b-eq-red (bred-repl (pmap (v 1 @) (pmap2 (rep2 m) idp apply_.trivial-apply *> r))))
        (b-eq-chain (rep2 (suc m) (v 1) (rep2 (n * suc m) (v 1) (v 0)))
            (b-eq.app-save-eq-right (rep2.save-beta-eq m (test4 n (suc m))))
            (b-eq-eq (pmap (v 1 @) (r2 *> pmap (\lam x => rep2 x (v 1) (v 0)) (repeat-linear-*-math-lemma m n))))
        )
  \where {
    \func test4-lemma (n : Nat) : b-eq (rep2 n (l (v 0)) (v 0)) (v 0) \elim n
      | 0 => b-eq-eq idp
      | suc n => b-eq-chain (rep2 n (l (v 0)) (v 0)) (b-eq-red (bred-repl apply_.trivial-apply)) (test4-lemma n)

    \func repeat-linear-*-math-lemma (m n : Nat) : m Nat.+ (n Nat.* m Nat.+ n) = suc n Nat.* m Nat.+ n =>
      rewrite (inv NatSemiring.+-assoc)
          (rewrite (NatSemiring.+-comm {m} {n * m})
              (rewrite
                  (rewrite (NatSemiring.*-comm {suc n} {m})
                      (rewrite (NatSemiring.*-comm {n} {m}) idp) : suc n * m = n * m + m)
                  idp
              )
          )
  }
