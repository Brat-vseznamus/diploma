\import Arith.Nat
\import Data.Bool
\import Function.Meta ($)
\import Logic
\import Paths
\import Paths.Meta
\import Set
\import calculus.Base
\import calculus.Types

-- TODO change to addOrUpdate
\data Context
  | empty
  | with (\Sigma Nat SimpleType) Context
  \where {
    \func rm-assump (assumption : \Sigma Nat SimpleType) (context : Context) : Context \elim assumption, context
      | (n,s), with _x _context => if (_x.1 == n) _context (with _x (rm-assump (n, s) _context))
      | (n,s), empty => empty
    \func add-assump (newAssumption : \Sigma Nat SimpleType) (context : Context) : Context \elim newAssumption, context
      | (n,s), with _x _context => with _x (if (_x.1 == n) _context (add-assump (n, s)  _context))
      | (n,s), empty => with (n, s) empty
    \func var-in-context (var : Nat) (c : Context) : Bool \elim c
      | empty => false
      | with (i, _) c => if (i == var) true (var-in-context var c)
    \func typed-var-in-context (var-with-type : \Sigma Nat SimpleType) (c : Context) : Bool \elim c
      | empty => false
      | with (i, t) c =>
        if (i == var-with-type.1)
            (t STDecSet.== var-with-type.2)
            (typed-var-in-context var-with-type c)
  }

\func CV (c : Context) : Array Nat \elim c
  | empty => nil
  | with _x c => addDistinct (CV c) _x.1

\func addDistinct (l : Array Nat) (x : Nat) : Array Nat \elim l
  | nil => x :: nil
  | a :: l => a :: if (a == x) (removeAll l x) (addDistinct l x)

\func removeAll (l : Array Nat) (x : Nat) : Array Nat \elim l
  | nil => nil
  | a :: l => if (a == x) (removeAll l x) (a :: removeAll l x)

\func distinct (l : Array Nat) : Array Nat \elim l
  | nil => nil
  | a :: l => a :: removeAll (distinct l) a

\func mergeUnique (l1 l2 : Array Nat) : Array Nat \elim l1
  | nil => distinct l2
  | a :: l => distinct (a :: mergeUnique l l2)

\func size (l : Array Nat) => l.len

\func filterByEq (l : Array Nat) (x : Nat) : Array Nat \elim l
  | nil => nil
  | a :: l => if (a == x) (a :: filterByEq l x) (filterByEq l x)

\func FV (e : Expr) : Array Nat \elim e
  | Con n => nil
  | Var n => n :: nil
  | Lam n e => removeAll (FV e) n
  | App e1 e2 => mergeUnique (FV e1) (FV e2)

\func V (e : Expr) : Array Nat \elim e
  | Con n => nil
  | Var n => n :: nil
  | Lam n e => V e
  | App e1 e2 => mergeUnique (V e2) (V e1)

\func \infix 6 leq (a b : Array Nat) : Bool \elim a
  | nil => true
  | a :: l => decToBool (in.decideIn a b) and (l leq b)

\func \infix 6 setEq (a b : Array Nat) : Bool => (a leq b) and (b leq a)

\truncated \data \infix 6 in (x : Nat) (l : Array Nat) : \Prop \elim l
  | a :: l => isHead (a = x)
  | a :: l => inTail (Not(a = x)) (x in l)
  \where {
    \func decideIn (x : Nat) (l : Array Nat) : Dec (x in l) \elim l
      | nil => no (\lam i => \case i \with {})
      | a :: l1 => \case decideEq a x \with {
        | yes e => yes (isHead e)
        | no n => \case decideIn x l1 \with {
          | yes e => yes (inTail n e)
          | no n1 => no (\lam i => \case i \with {
            | isHead p => n p
            | inTail n2 i1 => n1 i1
          })
        }
      }

    \func count (x : Nat) (l : Array Nat) : Nat \elim l
      | nil => 0
      | a :: l1 => if (a == x) (suc (count x l1)) (count x l1)

    \func size-next (a : Nat) (l : Array Nat) : size (a :: l) = suc (size l) \elim l
      | nil => idp
      | a1 :: l1 => idp

    \func filterAll (x : Nat) (l : Array Nat) (not-in : Not (x in l)) : filterByEq l x = nil \elim l
      | nil => idp
      | a :: l1 => \case decideEq a x \as d \return if (decToBool d) (a :: filterByEq l1 x) (filterByEq l1 x) = nil \with {
        | yes e => absurd (not-in (isHead e))
        | no n => filterAll x l1 (\lam i => not-in (inTail n i))
      }

    \func neutral-removeAll (l : Array Nat) (a x : Nat) (notEq : Not(a = x)) : filterByEq (removeAll l x) a = filterByEq l a \elim l
      | nil => idp
      | a1 :: l1 => \case decideEq a1 a \as d1, decideEq a1 x \as d2 \return filterByEq (if (decToBool d2) (removeAll l1 x) (a1 :: removeAll l1 x)) a = if (decToBool d1) (a1 :: filterByEq l1 a) (filterByEq l1 a) \with {
        | yes e, yes e1 => absurd (notEq (inv e *> e1))
        | yes e, no n => \case decideEq a1 a \as d3 \return if {Array Nat} (decToBool d3) (a1 :: filterByEq (removeAll l1 x) a) (filterByEq (removeAll l1 x) a) = a1 :: filterByEq l1 a \with {
          | yes e => pmap (a1 ::) $ neutral-removeAll l1 a x notEq
          | no n2 => absurd (n2 e)
        }
        | no n, yes e => neutral-removeAll l1 a x notEq
        | no n, no n1 => \case decideEq a1 a \as d3 \return if {Array Nat} (decToBool d3) (a1 :: filterByEq (removeAll l1 x) a) (filterByEq (removeAll l1 x) a) = filterByEq l1 a\with {
          | yes e => absurd (n e)
          | no n2 => neutral-removeAll l1 a x notEq
        }
      }

    \func filter-works {x : Nat} {l : Array Nat} : size (filterByEq l x) = count x l \elim l
      | nil => idp
      | a :: l1 => \case decideEq a x \as d \return size (if {Array Nat} (decToBool d) (a :: filterByEq l1 x) (filterByEq l1 x)) = if {Nat} (decToBool d) (suc (count x l1)) (count x l1) \with {
        | yes e =>
          \let
            | rec => pmap suc $ filter-works {x} {l1}
          \in lemma1 {a} {filterByEq l1 x} *> rec
        | no n => filter-works
      }
      \where {
        \func lemma1 {x : Nat} {l : Array Nat} : size (x :: l) = suc (size l) \elim l
          | nil => idp
          | a :: l1 => idp
      }

    \func distnict-works (l : Array Nat) : \Pi (x : Nat) (x in l) -> size(filterByEq (distinct l) x) = 1 \elim l
      | nil => \lam x i => absurd (\case x, i \with {})
      | a :: l1 => \lam x i => \case
        (decideEq a x) \as dec
      \return size (if (decToBool dec) (a :: filterByEq (removeAll (distinct l1) a) x) (filterByEq (removeAll (distinct l1) a) x)) = 1 \with {
        | yes e =>
          pmap
            (\lam p => size(a :: p))
            (
              pmap (\lam x_ => filterByEq (removeAll (distinct l1) x_) x) e *>
              filterAll x (removeAll (distinct l1) x) (rmv-works x (distinct l1))
            )
        | no ne => \case i \with {
          | isHead p => absurd (ne p)
          | inTail n i1 =>
            \let
              | not1 => \lam (e : a = x) =>
                  pmap
                      (\lam x_ => filterByEq (removeAll (distinct l1) x_) x) e *>
                      filterAll x (removeAll (distinct l1) x) (rmv-works x (distinct l1))
              | rec => distnict-works l1 x i1
            \in
              rewriteF (inv (neutral-removeAll (distinct l1) x a (\lam p => ne (inv p)))) rec
        }
      }

    \func add-works {x : Nat} {l : Array Nat} : x in addDistinct l x \elim l
      | nil => isHead idp
      | a :: l1 => \case decideEq a x \as d \return x in (a :: if (decToBool d) (removeAll l1 x) (addDistinct l1 x))  \with {
        | yes e => isHead e
        | no n => inTail n (add-works {x} {l1})
      }

    \func addDisticnt-add-one {x : Nat} {l : Array Nat} : size(filterByEq (addDistinct l x) x) = 1 \elim l
      | nil => \case decideEq x x \as d \return size (if (decToBool d) (x :: nil) nil) = 1 \with {
        | yes e => idp
        | no n => absurd (n idp)
      }
      | a :: l1 => \case decideEq a x \as d \return size(filterByEq (a :: if (decToBool d) (removeAll l1 x) (addDistinct l1 x)) x) = 1  \with {
        | yes e => \case decideEq a x \as d \return size (if (decToBool d) (a :: filterByEq (removeAll l1 x) x) (filterByEq (removeAll l1 x) x)) = 1 \with {
          | yes e1 =>
            \let
              | innerNil => filterAll x (removeAll l1 x) (rmv-works x l1)
            \in pmap (\lam l' => size (a :: l')) innerNil
          | no n => absurd (n e)
        }
        | no n => \case decideEq a x \as d \return size (if (decToBool d) (a :: filterByEq (addDistinct l1 x) x) (filterByEq (addDistinct l1 x) x)) = 1 \with {
          | yes e => absurd (n e)
          | no n1 => addDisticnt-add-one
        }
      }

    \func rmv-works (x : Nat) (l : Array Nat) : Not (x in removeAll l x) =>
      \lam i => rmv-work-lemma {x} {l} {i}
      \where {
        \func rmv-work-lemma {x : Nat} {l : Array Nat} {i : x in removeAll l x} : Empty \elim l, i
          | nil, i1 => \case i1 \with {}
          | a :: l1, i1 => \case decideEq a x \as r, i1 : (x in if (decToBool r) (removeAll l1 x) (a :: removeAll l1 x)) \with {
            | yes e, i2 => rmv-work-lemma {x} {l1} {i2}
            | no n, i2 => \case i2 \with {
              | isHead p => n p
              | inTail n1 i => rmv-work-lemma {x} {l1} {i}
            }
          }
        }
  }
