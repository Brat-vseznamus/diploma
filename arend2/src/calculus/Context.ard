\import Arith.Nat
\import Data.Bool
\import Function.Meta ($)
\import Logic
\import Paths
\import Paths.Meta
\import Set
\import calculus.Base
\import calculus.Types

-- TODO change to addOrUpdate
\data Context
  | empty
  | with (\Sigma Nat SimpleType) Context
  \where {
    \func rm-assump (assumption : \Sigma Nat SimpleType) (context : Context) : Context \elim assumption, context
      | (n,s), with _x _context => if (_x.1 == n) _context (with _x (rm-assump (n, s) _context))
      | (n,s), empty => empty
    \func add-assump (newAssumption : \Sigma Nat SimpleType) (context : Context) : Context \elim newAssumption, context
      | (n,s), with _x _context => with _x (if (_x.1 == n) _context (add-assump (n, s)  _context))
      | (n,s), empty => with (n, s) empty
    \func var-in-context (var : Nat) (c : Context) : Bool \elim c
      | empty => false
      | with (i, _) c => if (i == var) true (var-in-context var c)
    \func typed-var-in-context (var-with-type : \Sigma Nat SimpleType) (c : Context) : Bool \elim c
      | empty => false
      | with (i, t) c =>
        if (i == var-with-type.1)
            (t STDecSet.== var-with-type.2)
            (typed-var-in-context var-with-type c)
  }

\func CV (c : Context) : Array Nat \elim c
  | empty => nil
  | with _x c => addDistinct (CV c) _x.1

\func FV (e : Expr) : Array Nat \elim e
  | Con n => nil
  | Var n => n :: nil
  | Lam n e => removeAll (FV e) n
  | App e1 e2 => mergeUnique (FV e1) (FV e2)

\func V (e : Expr) : Array Nat \elim e
  | Con n => nil
  | Var n => n :: nil
  | Lam n e => V e
  | App e1 e2 => mergeUnique (V e2) (V e1)

