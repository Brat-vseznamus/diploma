\import Arith.Nat
\import Data.Bool
\import Data.Or
\import Function.Meta
\import Logic
\import Logic.Meta
\import Paths
\import Paths.Meta
\import Set \hiding (#)
\import calculus.Base
\import calculus.Beta
\import calculus.Church
\import calculus.Context
\import calculus.Defs
\import calculus.SubTerm
\import calculus.Types
\import calculus.theorems.Theorem1
\import calculus.theorems.Theorem2
\import calculus.theorems.common
\import math.sets
\import math.utils
\open Nat

\func const-zero : \Sigma (P : F 2) (ExtPoly {2} P) =>
  (\lam n1 n2 => 0, const 0 (\lam (arg-con _ (arg-con _ arg-empty)) => idp))

\func Theorem4_ {e : Expr_} {h : Nat} {c_ : Context_}
               (typed : TypedExpr_ e (A ~> A) (h + 3) c_)
               (nf : NormalForm e e)
               (no-con : \Pi (i : Nat) -> Not (SubTerm e (c i)))
               (closed : ClosedForm e (h + 3) c_)
               (con-req : \Pi (hc : Int) -> ConReq2 hc c_)
               (each-var-typed : VarsTypedCorrectly c_):
  Or
      (\Pi (n m : Nat) -> e apl (Numeral n, h + 2) apl (Numeral m, h + 1) = v h)
      (\Sigma
        (P00 P01 P10 P11 : F 2)
        (ExtPoly {2} P00)
        (ExtPoly {2} P01)
        (ExtPoly {2} P10)
        (ExtPoly {2} P11)
        (z00 z01 z10 z11 : Nat)
        (\Pi (n m : Nat) ->
            \Sigma
              (\Pi (n = 0) (m = 0) -> BetaEq (e apl (Numeral n, h + 2) apl (Numeral m, h + 1)) (l (rep2 (P00 n m) (v $ h + 1) (v z00))))
              (\Pi (n = 0) (m /= 0) -> BetaEq (e apl (Numeral n, h + 2) apl (Numeral m, h + 1)) (l (rep2 (P01 n m) (v $ h + 1) (v z01))))
              (\Pi (n /= 0) (m = 0) -> BetaEq (e apl (Numeral n, h + 2) apl (Numeral m, h + 1)) (l (rep2 (P10 n m) (v $ h + 1) (v z10))))
              (\Pi (n /= 0) (m /= 0) -> BetaEq (e apl (Numeral n, h + 2) apl (Numeral m, h + 1)) (l (rep2 (P11 n m) (v $ h + 1) (v z11))))
        )
      )
\elim e
  -- CONSTANT
  | c n => absurd (no-con n (sub-same idp))
  -- VARIABLE
  | v i =>
    inl
        \lam n m => \case
          i \as j,
          typed : TypedExpr_ (v j) (A ~> A) (suc (suc (suc h))) c_,
          nf : NormalForm (v j) (v j),
          no-con : \Pi (i : Nat) -> Not (SubTerm (v j) (c i)),
          typed : TypedExpr_ (v j) (A ~> A) (h + 3) c_,
          closed : ClosedForm (v j) (h + 3) c_
        \return v j apl (Numeral n, suc (suc h)) apl (Numeral m, suc h) = v h
        \with {
          | 0, t-var j-exists, nf_, no-con, typed, closed =>
            \let
              | r1 : 0 == suc (suc h) = false => {?}
              | r2 : 0 == suc h = false => {?}
            \in
            (
              pmap (\lam x => if x (apply_.shift+dh (Numeral n) (suc (suc h)) 0) (v 0) apl (Numeral m, suc h)) r1 *>
              (pmap (\lam x => if x (apply_.shift+dh (Numeral m) (suc h) 0) (v 0)) r2 *>
                (
                  \let
                    | theorem3 => Theorema2-3 (v 0) (A ~> A) h c_ con-req nf_ (t-var j-exists) (is2 idp)
                        no-con
                        leq-empty
                        each-var-typed
                        0
                        (sub-same idp)
                        idp
                    | h=0 : h = 0 =>
                      pmap
                          (\lam x => \case x \with {| pos (suc (suc (suc x))) => x | neg x => 0 | _ => 0})
                          (minus-rewrite {suc (suc (suc h))} {1} theorem3)

                  \in rewrite h=0 idp
                ) : if (0 == suc h) (apply_.shift+dh (Numeral m) (suc h) 0) (v 0) = v h
              ) : if (0 == suc (suc h)) (apply_.shift+dh (Numeral n) (suc (suc h)) 0) (v 0) apl (Numeral m, suc h) = v h)
          | suc j, t-var j-exists, nf_, no-con, typed, closed =>
            (
              \let
                | theorem3 => Theorema2-3 (v (suc j)) (A ~> A) h c_ con-req nf_ (t-var j-exists) (is2 idp)
                    no-con
                    closed
                    each-var-typed
                    (suc j)
                    (sub-same idp)
                    idp
                | tmp1 => minus-rewrite {suc (suc (suc h))} {suc (suc j)} theorem3
                | tmp2 : h = suc j => pmap (\lam x => \case x \with {| pos (suc (suc (suc x))) => x | neg x => 0 | _ => 0}) tmp1
                | tmp3 : suc j == suc (suc h) = false => {?}
                | tmp4 : isFree (suc j) (suc (suc h)) = false => {?}
                | tmp5 : suc j == suc h = false => {?}
                | tmp6 : isFree (suc j) (suc h) = false => {?}
              \in
                rewrite tmp3 $
                rewrite tmp4 $
                (
                  rewrite tmp5 $
                  rewrite tmp6 $
                  rewrite (inv tmp2) $
                  idp
                  : if (suc j == suc h) (apply_.shift+dh (Numeral m) (suc h) 0) (if (isFree (suc j) (suc h)) (v j) (v (suc j))) = v h
                )
              : if (suc j == suc (suc h)) (apply_.shift+dh (Numeral n) (suc (suc h)) 0) (if (isFree (suc j) (suc (suc h))) (v j) (v (suc j))) apl (Numeral m, suc h) = v h
            )
        }
  -- LAMBDA
  | l B => \case typed \with {
    | t-lam B-typed =>
      \let
        | (
            P00, P01, P10, P11,
            p00, p01, p10, p11,
            z00, z01, z10, z11,
            f
        ) => Theorem4_-var-lemma B-typed {?} {?} {?} {?} {?} -- TODO
      \in inr
          (
            P00, P01, P10, P11,
            p00, p01, p10, p11,
            z00, z01, z10, z11,
            \lam n m =>
                (
                  \lam p p2 => BetaEq.lam-save-eq ((f n m).1 p p2),
                  \lam p _x => BetaEq.lam-save-eq ((f n m).2 p _x),
                  \lam _x p => BetaEq.lam-save-eq ((f n m).3 _x p),
                  \lam _x _x1 => BetaEq.lam-save-eq ((f n m).4 _x _x1)
                )
          )
  }
  -- APPLICATION
  | e1 @ e2 =>
    \let
      | Th1 => Theorema1 (e1 @ e2) (A ~> A) (h + 3) c_ nf typed (is2 idp) no-con closed each-var-typed
      | leftType => Th1 e1 (sub-app-left (sub-same idp))
    \in
      \case typed \as tpd, leftType : inS (SubTerm.type-subterm
          (e1 @ e2) e1 (sub-app-left {e1} {e2} {e1} (sub-same {e1} {e1} (idp {Expr_} {e1}))) (A ~> A) (suc (suc (suc h))) c_ tpd).1 \with {
        | t-app tq P-typed Q-typed, lt =>
          \let
            | lt2 => rewrite SubTerm.ref lt
            | tq=A->A : tq = A ~> A => \case lt2 \with {
              | is1 p => contradiction
              | is2 p => contradiction
              | is3 p => pmap (\lam x => \case x \with {| a ~> b => a | _ => Base 0 }) p
            }
            | P-typed' => rewrite tq=A->A P-typed
            | Q-typed' => rewrite tq=A->A Q-typed
            | rec => Theorem4_ Q-typed'
                (NormalForm.nf (b-chain-end idp) (\lam _x => \case nf \with {
                  | NormalForm.nf b n => n (e1 @ _x.1, bred-app-right idp _x.2)
                }))
                (\lam i s => no-con i (sub-app-right s))
                (Theorema1.decon-closed {e1 @ e2} {e1} {e2} {h Nat.+ 3} {c_} {idp} closed).2
                con-req
                each-var-typed
            -- TODO prove it from resolving cases (not con obs, not apl bcs inS, not lam bcs lams only type A -> A)
            | isVar : Or (e1 = v (h + 2)) (e1 = v (h + 1)) => {?}
          \in \case isVar \with {
            | inl a => rewrite a
                (
                  \case rec \with {
                    | inl =f =>
                      inr (
                        \lam x _ => x,
                        \lam x _ => x,
                        \lam x _ => x,
                        \lam x _ => x,
                        pr0 (\lam x (arg-con y arg-empty) => idp),
                        pr0 (\lam x (arg-con y arg-empty) => idp),
                        pr0 (\lam x (arg-con y arg-empty) => idp),
                        pr0 (\lam x (arg-con y arg-empty) => idp),
                        0,
                        0,
                        0,
                        0,
                        \lam n m =>
                            \let
                              | =n : v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h) = Numeral n => {?}
                              | tmp1 => rep2.replace-args-left' {1} {n} {v 1} {v 0} {v h}
                            \in
                            (
                              \lam p p2 => (
                                rewrite (=f n m) $
                                rewrite =n $
                                b-eq-red (bred-repl (pmap l tmp1))
                                : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ ((e2 apl (Numeral n, suc (suc h))) apl (Numeral m, suc h))) (l (rep2 n (v (suc h)) (v 0)))
                              )
                              ,
                              \lam p p2 => (
                                rewrite (=f n m) $
                                rewrite =n $
                                b-eq-red (bred-repl (pmap l tmp1))
                                : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ ((e2 apl (Numeral n, suc (suc h))) apl (Numeral m, suc h))) (l (rep2 n (v (suc h)) (v 0)))
                                )
                              ,
                              \lam p p2 => (
                                rewrite (=f n m) $
                                rewrite =n $
                                b-eq-red (bred-repl (pmap l tmp1))
                                : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ ((e2 apl (Numeral n, suc (suc h))) apl (Numeral m, suc h))) (l (rep2 n (v (suc h)) (v 0)))
                              )
                              ,
                              \lam p p2 => (
                                rewrite (=f n m) $
                                rewrite =n $
                                b-eq-red (bred-repl (pmap l tmp1))
                                : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ ((e2 apl (Numeral n, suc (suc h))) apl (Numeral m, suc h))) (l (rep2 n (v (suc h)) (v 0)))
                              )
                            )
                      )
                    | inr (
                        P00, P01, P10, P11,
                        p00, p01, p10, p11,
                        z00, z01, z10, z11,
                        f
                    ) =>
                      \case decideEq z10 0 \as d1, decideEq z11 0 \as d2 \with {
                        | yes e, yes e3 =>
                          inr
                              (
                                const-zero.1,
                                const-zero.1,
                                \lam x y => x * P10 x y,
                                \lam x y => x * P11 x y,
                                const-zero.2,
                                const-zero.2,
                                mul (\lam x y => x) P10 (pr0 (\lam a1 (arg-con x arg-empty) => idp)) p10 (\lam (arg-con x (arg-con y arg-empty)) => idp),
                                mul (\lam x y => x) P11 (pr0 (\lam a1 (arg-con x arg-empty) => idp)) p11 (\lam (arg-con x (arg-con y arg-empty)) => idp),
                                0, 0, z10, z11,
                                \lam n m =>
                                    \let
                                      | =n : v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h) = Numeral n => {?}
                                      | tmp1 => rep2.replace-args-left' {1} {n} {v 1} {v 0} {v h}
                                    \in

                                      (
                                        \lam p p2 => (
                                            rewrite =n $
                                            rewrite p  $
                                            b-eq-red (bred-repl idp)
                                            : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (v 0))
                                        ),
                                        \lam p p2 => (
                                          rewrite =n $
                                          rewrite p  $
                                          b-eq-red (bred-repl idp)
                                          : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (v 0))
                                        ),
                                        \lam _x p =>
                                            (
                                            rewrite =n $
                                            b-eq-chain
                                                (Numeral n @ l (rep2 (P10 n m) (v (suc h)) (v z10)))
                                                (BetaEq.app-save-eq-right ((f n m).3 _x p))
                                                (rewrite e (Theorem4-lemma_ n P10 m h))
                                            : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (rep2 (n * P10 n m) (v (suc h)) (v z10)))) ,
                                        \lam _x _x1 =>
                                            (
                                              rewrite =n $
                                              b-eq-chain
                                                  (Numeral n @ l (rep2 (P11 n m) (v (suc h)) (v z11)))
                                                  (BetaEq.app-save-eq-right ((f n m).4 _x _x1))
                                                  (rewrite e3 (Theorem4-lemma_ n P11 m h))
                                              : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (rep2 (n * P11 n m) (v (suc h)) (v z11))))
                                      )
                              )
                        | yes e, no n1 =>
                          inr
                              (
                                const-zero.1,
                                const-zero.1,
                                \lam x y => x * P10 x y,
                                P11,
                                const-zero.2,
                                const-zero.2,
                                mul (\lam x y => x) P10 (pr0 (\lam a1 (arg-con x arg-empty) => idp)) p10 (\lam (arg-con x (arg-con y arg-empty)) => idp),
                                p11,
                                0, 0, z10, z11,
                                \lam n m =>
                                    \let
                                      | =n : v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h) = Numeral n => {?}
                                      | tmp1 => rep2.replace-args-left' {1} {n} {v 1} {v 0} {v h}
                                    \in

                                      (
                                        \lam p p2 => (
                                          rewrite =n $
                                          rewrite p  $
                                          b-eq-red (bred-repl idp)
                                          : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (v 0))
                                        ),
                                        \lam p p2 => (
                                          rewrite =n $
                                          rewrite p  $
                                          b-eq-red (bred-repl idp)
                                          : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (v 0))
                                        ),
                                        \lam _x p =>
                                            (
                                              rewrite =n $
                                              b-eq-chain
                                                  (Numeral n @ l (rep2 (P10 n m) (v (suc h)) (v z10)))
                                                  (BetaEq.app-save-eq-right ((f n m).3 _x p))
                                                  (rewrite e (Theorem4-lemma_ n P10 m h))
                                              : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (rep2 (n * P10 n m) (v (suc h)) (v z10)))) ,
                                        \lam _x _x1 =>
                                            (
                                              rewrite =n $
                                              b-eq-chain
                                                  (Numeral n @ l (rep2 (P11 n m) (v (suc h)) (v z11)))
                                                  (BetaEq.app-save-eq-right ((f n m).4 _x _x1))
                                                  (Theorem4_-lemma2 n P11 m h z11 n1)
                                              : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (rep2 (P11 n m) (v (suc h)) (v z11))))
                                      )
                              )
                        | no n1, yes e =>
                          inr
                              (
                                const-zero.1,
                                const-zero.1,
                                P10,
                                \lam x y => x * P11 x y,
                                const-zero.2,
                                const-zero.2,
                                p10,
                                mul (\lam x y => x) P11 (pr0 (\lam a1 (arg-con x arg-empty) => idp)) p11 (\lam (arg-con x (arg-con y arg-empty)) => idp),
                                0, 0, z10, z11,
                                \lam n m =>
                                    \let
                                      | =n : v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h) = Numeral n => {?}
                                      | tmp1 => rep2.replace-args-left' {1} {n} {v 1} {v 0} {v h}
                                    \in
                                      (
                                        \lam p p2 => (
                                          rewrite =n $
                                          rewrite p  $
                                          b-eq-red (bred-repl idp)
                                          : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (v 0))
                                        ),
                                        \lam p p2 => (
                                          rewrite =n $
                                          rewrite p  $
                                          b-eq-red (bred-repl idp)
                                          : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (v 0))
                                        ),
                                        \lam _x p =>
                                            (
                                              rewrite =n $
                                              b-eq-chain
                                                  (Numeral n @ l (rep2 (P10 n m) (v (suc h)) (v z10)))
                                                  (BetaEq.app-save-eq-right ((f n m).3 _x p))
                                                  (Theorem4_-lemma2 n P10 m h z10 n1)
                                              : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (rep2 (P10 n m) (v (suc h)) (v z10)))) ,
                                        \lam _x _x1 =>
                                            (
                                              rewrite =n $
                                              b-eq-chain
                                                  (Numeral n @ l (rep2 (P11 n m) (v (suc h)) (v z11)))
                                                  (BetaEq.app-save-eq-right ((f n m).4 _x _x1))
                                                  (rewrite e (Theorem4-lemma_ n P11 m h))
                                              : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (rep2 (n * P11 n m) (v (suc h)) (v z11))))
                                      )
                              )
                        | no n1, no n2 =>
                          inr
                              (
                                const-zero.1,
                                const-zero.1,
                                P10,
                                P11,
                                const-zero.2,
                                const-zero.2,
                                p10,
                                p11,
                                0, 0, z10, z11,
                                \lam n m =>
                                    \let
                                      | =n : v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h) = Numeral n => {?}
                                      | tmp1 => rep2.replace-args-left' {1} {n} {v 1} {v 0} {v h}
                                    \in
                                      (
                                        \lam p p2 => (
                                          rewrite =n $
                                          rewrite p  $
                                          b-eq-red (bred-repl idp)
                                          : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (v 0))
                                        ),
                                        \lam p p2 => (
                                          rewrite =n $
                                          rewrite p  $
                                          b-eq-red (bred-repl idp)
                                          : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (v 0))
                                        ),
                                        \lam _x p =>
                                            (
                                              rewrite =n $
                                              b-eq-chain
                                                  (Numeral n @ l (rep2 (P10 n m) (v (suc h)) (v z10)))
                                                  (BetaEq.app-save-eq-right ((f n m).3 _x p))
                                                  (Theorem4_-lemma2 n P10 m h z10 n1)
                                              : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (rep2 (P10 n m) (v (suc h)) (v z10)))) ,
                                        \lam _x _x1 =>
                                            (
                                              rewrite =n $
                                              b-eq-chain
                                                  (Numeral n @ l (rep2 (P11 n m) (v (suc h)) (v z11)))
                                                  (BetaEq.app-save-eq-right ((f n m).4 _x _x1))
                                                  (Theorem4_-lemma2 n P11 m h z11 n2)
                                              : BetaEq ((v (suc (suc h)) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (rep2 (P11 n m) (v (suc h)) (v z11))))
                                      )
                              )
                      }
                  }
                )
            | inr b => rewrite b
                (
                  \case rec \with {
                    | inl =f =>
                      inr (
                        \lam _ y => y,
                        \lam _ y => y,
                        \lam _ y => y,
                        \lam _ y => y,
                        down (\lam x => x) (pr0 (\lam a (arg-empty) => idp)) (\lam a (arg-con x arg-empty) => idp),
                        down (\lam x => x) (pr0 (\lam a (arg-empty) => idp)) (\lam a (arg-con x arg-empty) => idp),
                        down (\lam x => x) (pr0 (\lam a (arg-empty) => idp)) (\lam a (arg-con x arg-empty) => idp),
                        down (\lam x => x) (pr0 (\lam a (arg-empty) => idp)) (\lam a (arg-con x arg-empty) => idp),
                        0,
                        0,
                        0,
                        0,
                        \lam n m =>
                            \let
                              | =m : v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h) = Numeral m => {?}
                              | tmp1 => rep2.replace-args-left' {1} {m} {v 1} {v 0} {v h}
                            \in
                              (
                                \lam p p2 => (
                                  rewrite (=f n m) $
                                  rewrite =m $
                                  b-eq-red (bred-repl (pmap l tmp1))
                                  : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ ((e2 apl (Numeral n, suc (suc h))) apl (Numeral m, suc h))) (l (rep2 m (v (suc h)) (v 0)))
                                )
                              ,
                                \lam p p2 => (
                                  rewrite (=f n m) $
                                  rewrite =m $
                                  b-eq-red (bred-repl (pmap l tmp1))
                                  : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ ((e2 apl (Numeral n, suc (suc h))) apl (Numeral m, suc h))) (l (rep2 m (v (suc h)) (v 0)))
                                )
                              ,
                                \lam p p2 => (
                                  rewrite (=f n m) $
                                  rewrite =m $
                                  b-eq-red (bred-repl (pmap l tmp1))
                                  : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ ((e2 apl (Numeral n, suc (suc h))) apl (Numeral m, suc h))) (l (rep2 m (v (suc h)) (v 0)))
                                )
                              ,
                                \lam p p2 => (
                                  rewrite (=f n m) $
                                  rewrite =m $
                                  b-eq-red (bred-repl (pmap l tmp1))
                                  : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ ((e2 apl (Numeral n, suc (suc h))) apl (Numeral m, suc h))) (l (rep2 m (v (suc h)) (v 0)))
                                )
                              )
                      )
                    | inr (
                    P00, P01, P10, P11,
                    p00, p01, p10, p11,
                    z00, z01, z10, z11,
                    f
                    ) =>
                      \case decideEq z01 0 \as d1, decideEq z11 0 \as d2 \with {
                        | yes e, yes e3 =>
                          inr
                              (
                                const-zero.1,
                                \lam x y => y * P01 x y,
                                const-zero.1,
                                \lam x y => y * P11 x y,
                                const-zero.2,
                                mul (\lam x y => y) P01 (down (\lam x => x) (pr0 (\lam a (arg-empty) => idp)) (\lam a (arg-con x arg-empty) => idp)) p01 (\lam (arg-con x (arg-con y arg-empty)) => idp),
                                const-zero.2,
                                mul (\lam x y => y) P11 (down (\lam x => x) (pr0 (\lam a (arg-empty) => idp)) (\lam a (arg-con x arg-empty) => idp)) p11 (\lam (arg-con x (arg-con y arg-empty)) => idp),
                                0, z01, 0, z11,
                                \lam n m =>
                                    \let
                                      | =m : v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h) = Numeral m => {?}
                                      | tmp1 => rep2.replace-args-left' {1} {m} {v 1} {v 0} {v h}
                                    \in
                                      (
                                        \lam p p2 =>
                                          (
                                            rewrite =m $
                                            rewrite p2 $
                                            b-eq-red (bred-repl idp)
                                            : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (v 0))
                                          ),
                                        \lam p _x =>
                                          (
                                            rewrite =m $
                                            b-eq-chain
                                                (Numeral m @ l (rep2 (P01 n m) (v (suc h)) (v z01)))
                                                (BetaEq.app-save-eq-right ((f n m).2 p _x))
                                                (rewrite e $ Theorem4_-lemma3 m P01 n h)
                                            : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (rep2 (m * P01 n m) (v (suc h)) (v z01)))
                                          ),
                                        \lam _x p =>
                                            (
                                              rewrite =m $
                                              rewrite p $
                                              b-eq-red (bred-repl idp)
                                              : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (v 0))
                                            ),
                                        \lam _x _x1 =>
                                            (
                                              rewrite =m $
                                              b-eq-chain
                                                  (Numeral m @ l (rep2 (P11 n m) (v (suc h)) (v z11)))
                                                  (BetaEq.app-save-eq-right ((f n m).4 _x _x1))
                                                  (rewrite e3 $ Theorem4_-lemma3 m P11 n h)
                                              : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (rep2 (m * P11 n m) (v (suc h)) (v z11)))
                                            )
                                      )
                              )
                        | yes e, no n1 =>
                          inr
                              (
                                const-zero.1,
                                \lam x y => y * P01 x y,
                                const-zero.1,
                                P11,
                                const-zero.2,
                                mul (\lam x y => y) P01 (down (\lam x => x) (pr0 (\lam a (arg-empty) => idp)) (\lam a (arg-con x arg-empty) => idp)) p01 (\lam (arg-con x (arg-con y arg-empty)) => idp),
                                const-zero.2,
                                p11,
                                0, z01, 0, z11,
                                \lam n m =>
                                    \let
                                      | =m : v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h) = Numeral m => {?}
                                      | tmp1 => rep2.replace-args-left' {1} {m} {v 1} {v 0} {v h}
                                    \in
                                      (
                                        \lam p p2 =>
                                            (
                                              rewrite =m $
                                              rewrite p2 $
                                              b-eq-red (bred-repl idp)
                                              : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (v 0))
                                            ),
                                        \lam p _x =>
                                            (
                                              rewrite =m $
                                              b-eq-chain
                                                  (Numeral m @ l (rep2 (P01 n m) (v (suc h)) (v z01)))
                                                  (BetaEq.app-save-eq-right ((f n m).2 p _x))
                                                  (rewrite e $ Theorem4_-lemma3 m P01 n h)
                                              : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (rep2 (m * P01 n m) (v (suc h)) (v z01)))
                                            ),
                                        \lam _x p =>
                                            (
                                              rewrite =m $
                                              rewrite p $
                                              b-eq-red (bred-repl idp)
                                              : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (v 0))
                                            ),
                                        \lam _x _x1 =>
                                            (
                                              rewrite =m $
                                              b-eq-chain
                                                  (Numeral m @ l (rep2 (P11 n m) (v (suc h)) (v z11)))
                                                  (BetaEq.app-save-eq-right ((f n m).4 _x _x1))
                                                  (Theorem4_-lemma4 m P11 n h z11 n1)
                                              : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (rep2 (P11 n m) (v (suc h)) (v z11)))
                                            )
                                      )
                              )
                        | no n1, yes e =>
                          inr
                              (
                                const-zero.1,
                                P01,
                                const-zero.1,
                                \lam x y => y * P11 x y,
                                const-zero.2,
                                p01,
                                const-zero.2,
                                mul (\lam x y => y) P11 (down (\lam x => x) (pr0 (\lam a (arg-empty) => idp)) (\lam a (arg-con x arg-empty) => idp)) p11 (\lam (arg-con x (arg-con y arg-empty)) => idp),
                                0, z01, 0, z11,
                                \lam n m =>
                                    \let
                                      | =m : v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h) = Numeral m => {?}
                                      | tmp1 => rep2.replace-args-left' {1} {m} {v 1} {v 0} {v h}
                                    \in
                                      (
                                        \lam p p2 =>
                                            (
                                              rewrite =m $
                                              rewrite p2 $
                                              b-eq-red (bred-repl idp)
                                              : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (v 0))
                                            ),
                                        \lam p _x =>
                                            (
                                              rewrite =m $
                                              b-eq-chain
                                                  (Numeral m @ l (rep2 (P01 n m) (v (suc h)) (v z01)))
                                                  (BetaEq.app-save-eq-right ((f n m).2 p _x))
                                                  (Theorem4_-lemma4 m P01 n h z01 n1)
                                              : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (rep2 (P01 n m) (v (suc h)) (v z01)))
                                            ),
                                        \lam _x p =>
                                            (
                                              rewrite =m $
                                              rewrite p $
                                              b-eq-red (bred-repl idp)
                                              : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (v 0))
                                            ),
                                        \lam _x _x1 =>
                                            (
                                              rewrite =m $
                                              b-eq-chain
                                                  (Numeral m @ l (rep2 (P11 n m) (v (suc h)) (v z11)))
                                                  (BetaEq.app-save-eq-right ((f n m).4 _x _x1))
                                                  (rewrite e $ Theorem4_-lemma3 m P11 n h)
                                              : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (rep2 (m * P11 n m) (v (suc h)) (v z11)))
                                            )
                                      )
                              )
                        | no n1, no n2 =>
                          inr
                              (
                                const-zero.1,
                                P01,
                                const-zero.1,
                                P11,
                                const-zero.2,
                                p01,
                                const-zero.2,
                                p11,
                                0, z01, 0, z11,
                                \lam n m =>
                                    \let
                                      | =m : v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h) = Numeral m => {?}
                                      | tmp1 => rep2.replace-args-left' {1} {m} {v 1} {v 0} {v h}
                                    \in
                                      (
                                        \lam p p2 =>
                                            (
                                              rewrite =m $
                                              rewrite p2 $
                                              b-eq-red (bred-repl idp)
                                              : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (v 0))
                                            ),
                                        \lam p _x =>
                                            (
                                              rewrite =m $
                                              b-eq-chain
                                                  (Numeral m @ l (rep2 (P01 n m) (v (suc h)) (v z01)))
                                                  (BetaEq.app-save-eq-right ((f n m).2 p _x))
                                                  (Theorem4_-lemma4 m P01 n h z01 n1)
                                              : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (rep2 (P01 n m) (v (suc h)) (v z01)))
                                            ),
                                        \lam _x p =>
                                            (
                                              rewrite =m $
                                              rewrite p $
                                              b-eq-red (bred-repl idp)
                                              : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (v 0))
                                            ),
                                        \lam _x _x1 =>
                                            (
                                              rewrite =m $
                                              b-eq-chain
                                                  (Numeral m @ l (rep2 (P11 n m) (v (suc h)) (v z11)))
                                                  (BetaEq.app-save-eq-right ((f n m).4 _x _x1))
                                                  (Theorem4_-lemma4 m P11 n h z11 n2)
                                              : BetaEq ((v (suc h) apl (Numeral n, suc (suc h)) apl (Numeral m, suc h)) @ (e2 apl (Numeral n, suc (suc h)) apl (Numeral m, suc h))) (l (rep2 (P11 n m) (v (suc h)) (v z11)))
                                            )
                                      )
                              )
                      }
                  }
              )
          }
      }
  \where {
    \func Theorem4-lemma_ (n : Nat) (P : F 2) (m h : Nat) : BetaEq (Numeral n @ l (rep2 (P n m) (v (suc h)) (v 0))) (l (rep2 (n * P n m) (v (suc h)) (v 0))) \elim n
      | 0 => rewrite NatSemiring.zro_*-left
          (b-eq-chain
              (l (v 0) apl (l (rep2 (P 0 m) (v (suc h)) (v 0)), 0))
              (b-eq-red (bred-repl idp))
              (b-eq-eq (pmap l idp))
          )
      | suc n => \let r => Theorem4-lemma_ n P m h \in {?} -- TODO *-def proof

    \func Theorem4_-lemma2 (k : Nat) (Q : F 2) (m h j : Nat) (not-zero : j /= 0) : BetaEq (Numeral k @ l (rep2 (Q k m) (v (suc h)) (v j))) (l (rep2 (Q k m) (v (suc h)) (v j))) =>
      {?}

    \func Theorem4_-lemma3 (m : Nat) (P : F 2) (n h : Nat) : BetaEq (Numeral m @ l (rep2 (P n m) (v (suc h)) (v 0))) (l (rep2 (m * P n m) (v (suc h)) (v 0))) =>
      {?}

    \func Theorem4_-lemma4 (k : Nat) (Q : F 2) (n h j : Nat) (not-zero : j /= 0) : BetaEq (Numeral k @ l (rep2 (Q n k) (v (suc h)) (v j))) (l (rep2 (Q n k) (v (suc h)) (v j))) =>
      {?}



    \func Theorem4_-var-lemma {e : Expr_} {h : Nat} {c_ : Context_}
                              (typed : TypedExpr_ e A (h + 3) c_)
                              (nf : NormalForm e e)
                              (no-con : \Pi (i : Nat) -> Not (SubTerm e (c i)))
                              (closed : ClosedForm e (h + 3) c_)
                              (con-req : \Pi (hc : Int) -> ConReq2 hc c_)
                              (each-var-typed : VarsTypedCorrectly c_)
      :
      \Sigma
        (P00 P01 P10 P11 : F 2)
        (ExtPoly {2} P00)
        (ExtPoly {2} P01)
        (ExtPoly {2} P10)
        (ExtPoly {2} P11)
        (z00 z01 z10 z11 : Nat)
        (\Pi (n m : Nat) ->
            \Sigma
              (\Pi (n = 0) (m = 0) -> BetaEq (e apl (Numeral n, h + 2) apl (Numeral m, h + 1)) (rep2 (P00 n m) (v h) (v z00)))
              (\Pi (n = 0) (m /= 0) -> BetaEq (e apl (Numeral n, h + 2) apl (Numeral m, h + 1)) (rep2 (P01 n m) (v h) (v z01)))
              (\Pi (n /= 0) (m = 0) -> BetaEq (e apl (Numeral n, h + 2) apl (Numeral m, h + 1)) (rep2 (P10 n m) (v h) (v z10)))
              (\Pi (n /= 0) (m /= 0) -> BetaEq (e apl (Numeral n, h + 2) apl (Numeral m, h + 1)) (rep2 (P11 n m) (v h) (v z11)))
        )
      \elim e, typed
        | c n, t-con => absurd (no-con n (sub-same idp))
        | v 0,       t-var i-exist => \case decideEq 0 (suc (suc h)) \as d
          \return \Sigma (P00 P01 P10 P11 : F 2) (ExtPoly {2} P00) (ExtPoly {2} P01) (ExtPoly {2} P10) (ExtPoly {2} P11) (z00 z01 z10 z11 : Nat)
                         (\Pi (n m : Nat) ->
                             \Sigma (n = 0 -> m = 0 -> BetaEq (if (decToBool d) (apply_.shift+dh (Numeral n) (suc (suc h)) 0) (v 0) apl (Numeral m, suc h)) (rep2 (P00 n m) (v h) (v z00)))
                                    (n = 0 -> m /= 0 -> BetaEq (if (decToBool d) (apply_.shift+dh (Numeral n) (suc (suc h)) 0) (v 0) apl (Numeral m, suc h)) (rep2 (P01 n m) (v h) (v z01)))
                                    (n /= 0 -> m = 0 -> BetaEq (if (decToBool d) (apply_.shift+dh (Numeral n) (suc (suc h)) 0) (v 0) apl (Numeral m, suc h)) (rep2 (P10 n m) (v h) (v z10)))
                                    (n /= 0 -> m /= 0 -> BetaEq (if (decToBool d) (apply_.shift+dh (Numeral n) (suc (suc h)) 0) (v 0) apl (Numeral m, suc h)) (rep2 (P11 n m) (v h) (v z11))))\with {
          | yes e => absurd (suc/=0 (inv e))
          | no n => \case decideEq 0 (suc h) \as d
          \return \Sigma (P00 P01 P10 P11 : F 2) (ExtPoly {2} P00) (ExtPoly {2} P01) (ExtPoly {2} P10) (ExtPoly {2} P11) (z00 z01 z10 z11 : Nat)
                         (\Pi (n m : Nat) -> \Sigma (n = 0 -> m = 0 -> BetaEq (if (decToBool d) (apply_.shift+dh (Numeral m) (suc h) 0) (v 0)) (rep2 (P00 n m) (v h) (v z00)))
                                                    (n = 0 -> m /= 0 -> BetaEq (if (decToBool d) (apply_.shift+dh (Numeral m) (suc h) 0) (v 0)) (rep2 (P01 n m) (v h) (v z01)))
                                                    (n /= 0 -> m = 0 -> BetaEq (if (decToBool d) (apply_.shift+dh (Numeral m) (suc h) 0) (v 0)) (rep2 (P10 n m) (v h) (v z10)))
                                                    (n /= 0 -> m /= 0 -> BetaEq (if (decToBool d) (apply_.shift+dh (Numeral m) (suc h) 0) (v 0)) (rep2 (P11 n m) (v h) (v z11))))\with {
            | yes e => absurd (suc/=0 (inv e))
            | no n1 =>
              (
                const-zero.1, const-zero.1, const-zero.1, const-zero.1,
                const-zero.2, const-zero.2, const-zero.2, const-zero.2,
                0, 0, 0, 0,
                \lam n2 m =>
                    (
                      \lam p p1 => b-eq-eq idp,
                      \lam p p1 => b-eq-eq idp,
                      \lam p p1 => b-eq-eq idp,
                      \lam p p1 => b-eq-eq idp
                    )
             )
          }
        }

        | v (suc j), t-var i-exist => \case j \as i, decideEq (suc j) (suc (suc h)) \as d
          \return \Sigma (P00 P01 P10 P11 : F 2) (ExtPoly {2} P00) (ExtPoly {2} P01) (ExtPoly {2} P10) (ExtPoly {2} P11) (z00 z01 z10 z11 : Nat)
                         (\Pi (n m : Nat) ->
                             \Sigma (n = 0 -> m = 0 -> BetaEq (if (decToBool d) (apply_.shift+dh (Numeral n) (suc (suc h)) 0) (if (isFree (suc j) (suc (suc h))) (v j) (v (suc j))) apl (Numeral m, suc h)) (rep2 (P00 n m) (v h) (v z00)))
                                    (n = 0 -> m /= 0 -> BetaEq (if (decToBool d) (apply_.shift+dh (Numeral n) (suc (suc h)) 0) (if (isFree (suc j) (suc (suc h))) (v j) (v (suc j))) apl (Numeral m, suc h)) (rep2 (P01 n m) (v h) (v z01)))
                                    (n /= 0 -> m = 0 -> BetaEq (if (decToBool d) (apply_.shift+dh (Numeral n) (suc (suc h)) 0) (if (isFree (suc j) (suc (suc h))) (v j) (v (suc j))) apl (Numeral m, suc h)) (rep2 (P10 n m) (v h) (v z10)))
                                    (n /= 0 -> m /= 0 -> BetaEq (if (decToBool d) (apply_.shift+dh (Numeral n) (suc (suc h)) 0) (if (isFree (suc j) (suc (suc h))) (v j) (v (suc j))) apl (Numeral m, suc h)) (rep2 (P11 n m) (v h) (v z11)))) \with {
          | j, yes e => {?}
          | j, no n => {?}
        }
        | e @ e1, t-app tq typed1 typed2 => {?}
  }