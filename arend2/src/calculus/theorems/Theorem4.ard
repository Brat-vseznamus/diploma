\import Arith.Nat
\import Data.Bool
\import Data.Or
\import Function.Meta
\import Logic
\import Logic.Meta
\import Paths
\import Paths.Meta
\import Set
\import calculus.Base
\import calculus.Beta
\import calculus.Church
\import calculus.Context
\import calculus.Defs
\import calculus.SubTerm
\import calculus.Types
\import calculus.theorems.Theorem1
\import calculus.theorems.Theorem2
\import calculus.theorems.common
\import math.sets
\import math.utils
\open Nat

\func const-zero : \Sigma (P : F 2) (ExtPoly {2} P) =>
  (\lam n1 n2 => 0, const 0 (\lam (arg-con _ (arg-con _ arg-empty)) => idp))

\func Theorem4 {e : Expr_} {h : Nat} {c_ : Context_}
    (typed : TypedExpr_ e (A ~> A) (h + 3) c_)
    (nf : NormalForm e e)
    (no-con : \Pi (i : Nat) -> Not (SubTerm e (c i)))
    (closed : ClosedForm e (h + 3) c_)
    (con-req : \Pi (hc : Int) -> ConReq2 hc c_)
    (each-var-typed : VarsTypedCorrectly c_):
  \Sigma
    (P : F 2)
    (ExtPoly {2} P)
    (\Pi (n m : Nat) ->
        Or
            (e apl (Numeral n, h + 2) apl (Numeral m, h + 1) = v h)
            (\Sigma (j : Nat) (BetaEq (e apl (Numeral n, h + 2) apl (Numeral m, h + 1)) (l $ rep2 (P n m) (v (h + 1)) (v j))))
    )
  \elim e
    -- CONSTANT
    | c n => absurd (no-con n (sub-same idp))
    -- VARIABLE
    | v i =>
      (
        const-zero.1,
        const-zero.2,
        \lam n m => inl (
          \case
            i \as j,
            typed : TypedExpr_ (v j) (A ~> A) (suc (suc (suc h))) c_,
            nf : NormalForm (v j) (v j),
            no-con : \Pi (i : Nat) -> Not (SubTerm (v j) (c i)),
            typed : TypedExpr_ (v j) (A ~> A) (h + 3) c_,
            closed : ClosedForm (v j) (h + 3) c_
            \return v j apl (Numeral n, suc (suc h)) apl (Numeral m, suc h) = v h
          \with {
            | 0, t-var j-exists, nf_, no-con, typed, closed =>
              (
                pmap (\lam x => if x (apply_.shift+dh (Numeral n) (suc (suc h)) 0) (v 0) apl (Numeral m, suc h))
                    ({?} : 0 == suc (suc h) = false)
                  *>
                (
                  pmap (\lam x => if x (apply_.shift+dh (Numeral m) (suc h) 0) (v 0))
                      ({?} : 0 == suc h = false)
                    *>
                  (
                    \let
                      | theorem3 => Theorema2-3 (v 0) (A ~> A) h c_ con-req nf_ (t-var j-exists) (is2 idp)
                          no-con
                          leq-empty
                          each-var-typed
                          0
                          (sub-same idp)
                          idp
                      | h=0 : h = 0 =>
                        pmap
                            (\lam x => \case x \with {| pos (suc (suc (suc x))) => x | neg x => 0 | _ => 0})
                            (minus-rewrite {suc (suc (suc h))} {1} theorem3)

                    \in rewrite h=0 idp
                  )
                  : if (0 == suc h) (apply_.shift+dh (Numeral m) (suc h) 0) (v 0) = v h
                )
                : if (0 == suc (suc h)) (apply_.shift+dh (Numeral n) (suc (suc h)) 0) (v 0) apl (Numeral m, suc h) = v h
              )
            | suc j, t-var j-exists, nf_, no-con, typed, closed =>
              (
                \let
                  | theorem3 => Theorema2-3 (v (suc j)) (A ~> A) h c_ con-req nf_ (t-var j-exists) (is2 idp)
                      no-con
                      closed
                      each-var-typed
                      (suc j)
                      (sub-same idp)
                      idp
                  | tmp1 => minus-rewrite {suc (suc (suc h))} {suc (suc j)} theorem3
                  | tmp2 : h = suc j => pmap (\lam x => \case x \with {| pos (suc (suc (suc x))) => x | neg x => 0 | _ => 0}) tmp1
                  | tmp3 : suc j == suc (suc h) = false => {?}
                  | tmp4 : isFree (suc j) (suc (suc h)) = false => {?}
                  | tmp5 : suc j == suc h = false => {?}
                  | tmp6 : isFree (suc j) (suc h) = false => {?}
                \in
                  rewrite tmp3 $
                  rewrite tmp4 $
                  (
                    rewrite tmp5 $
                    rewrite tmp6 $
                    rewrite (inv tmp2) $
                    idp
                    : if (suc j == suc h) (apply_.shift+dh (Numeral m) (suc h) 0) (if (isFree (suc j) (suc h)) (v j) (v (suc j))) = v h
                  )
                : if (suc j == suc (suc h)) (apply_.shift+dh (Numeral n) (suc (suc h)) 0) (if (isFree (suc j) (suc (suc h))) (v j) (v (suc j))) apl (Numeral m, suc h) = v h
              )
        })
      )
    -- LAMBDA
    | l (c x) => absurd (no-con x (sub-lam (sub-same idp)))
    | l (v x) =>
      (
        const-zero.1,
        const-zero.2,
        \case decideEq x (suc (suc (suc h))) \as d1, decideEq x (suc (suc h)) \as d2 \with {
          | yes e, yes e1 => absurd (a/=suc_a (inv e1 *> e))
          | yes e, no n => {?}
          | no n, yes e => {?}
          | no n, no n1 => {?}
        }
--        \lam n m => inr (x, b-eq-eq (pmap l {?}))
      )
    | l (P @ a) => {?}
    | l (l r) => \case typed \with {
      | t-lam B-typed => \case B-typed \with {}
    }
    -- APPLICATION
    | e1 @ e2 =>
      \let
        | Th1 => Theorema1 (e1 @ e2) (A ~> A) (h + 3) c_ nf typed (is2 idp) no-con closed each-var-typed
        | leftType => Th1 e1 (sub-app-left (sub-same idp))
      \in
      \case typed \as tpd, leftType : inS (SubTerm.type-subterm
          (e1 @ e2) e1 (sub-app-left {e1} {e2} {e1} (sub-same {e1} {e1} (idp {Expr_} {e1}))) (A ~> A) (suc (suc (suc h))) c_ tpd).1 \with {
        | t-app tq P-typed Q-typed, lt =>
            \let
              | lt2 => rewrite SubTerm.ref lt
              | tq=A->A : tq = A ~> A => \case lt2 \with {
                | is1 p => contradiction
                | is2 p => contradiction
                | is3 p => pmap (\lam x => \case x \with {| a ~> b => a | _ => Base 0 }) p
              }
              | P-typed' => rewrite tq=A->A P-typed
              | Q-typed' => rewrite tq=A->A Q-typed
              | rec => Theorem4 Q-typed'
                  (NormalForm.nf (b-chain-end idp) (\lam _x => \case nf \with {
                    | NormalForm.nf b n => n (e1 @ _x.1, bred-app-right idp _x.2)
                  }))
                  (\lam i s => no-con i (sub-app-right s))
                  (Theorema1.decon-closed {e1 @ e2} {e1} {e2} {h Nat.+ 3} {c_} {idp} closed).2
                  con-req
                  each-var-typed
              -- TODO prove it from resolving cases (not con obs, not apl bcs inS, not lam bcs lams only type A -> A)
              | isVar : Or (e1 = v (h + 1)) (e1 = v (h + 2)) => {?}
            \in \case isVar \with {
              | inl a => rewrite a
                  (
                    {?},
                    {?},
                    {?}
                  )
              | inr b => rewrite b {?}
            }
      }