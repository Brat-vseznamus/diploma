\import Arith.Nat
\import Data.Bool
\import Data.Or
\import Logic
\import Paths
\import Paths.Meta
\import Set
\import calculus.AlphaEq
\import calculus.AlphaEq2
\import calculus.Beta
\import calculus.Context
\import calculus.SubTerm
\import calculus.Types
\import math.sets

\data Expr : \Set
  | Con Nat
  | Var Nat
  | Lam Nat Expr
  | App Expr Expr
  \where {
    \func app-decon {P1 Q1 P2 Q2 : Expr} (p : App P1 Q1 = App P2 Q2) : \Sigma (P1 = P2) (Q1 = Q2) =>
      (
        pmap (\lam x => \case x \with {| Con n => Con 0 | Var n => Con 0 | Lam n e => Con 0| App e e1 => e}) p,
        pmap (\lam x => \case x \with {| Con n => Con 0 | Var n => Con 0 | Lam n e => Con 0| App e e1 => e1}) p
      )
  }

\data TypedExpr (e : Expr) (t : SimpleType) (c : Context) \elim e, t, c
  | (Con _), t, c => typed-const
  | (Var i), t, c => typed-var (i-exists : Context.typed-var-in-context (i, t) c = true)
  | (Lam i B), (Func a b), c => typed-lam
    (b-typed      : TypedExpr B b (Context.update-assump (i, a) c))
  | (App P Q), t, c => typed-app
    (Qt : SimpleType)
    (p-typed : TypedExpr P (Func Qt t) c)
    (q-typed : TypedExpr Q Qt c)
  \where {
    \func lam-has-func-type {B : Expr} {i : Nat} {t : SimpleType} {c : Context} (typed : TypedExpr (Lam i B) t c) :
      \Sigma (a b : SimpleType) (t = Func a b)
      \elim t, typed
        | Func t1 t2, typed-lam typed => (t1, t2, idp)

    \func app-parts-types {P Q : Expr} {t : SimpleType} {c : Context} (typed : TypedExpr (App P Q) t c) :
      \Sigma (a b : SimpleType) (TypedExpr P (Func a b) c) (TypedExpr Q a c)
      \elim t, typed
        | Rt, typed-app Qt typed typed1 => (Qt, Rt, typed, typed1)

    -- TODO remove no-con
    -- TODO carry instead of church or mention that we have second
--    \func type-unique {e : Expr} {a b : SimpleType} {c : Context}
--                      {no-con : Not (\Sigma (n : Nat) (SubTerm e (Con n)))}
--                      {no-lam : Not (\Sigma (n : Nat) (B : Expr) (e = Lam n B))}
--                      (p1 : TypedExpr e a c) (p2 : TypedExpr e b c) : a = b \elim e, a, b, p1, p2
--      | Con n, a, b, typed-const, typed-const => absurd (no-con (n, sub-same idp))
--      | Var i, a, b, typed-var i-exists, typed-var i-exists1 => Context.type-unique i-exists i-exists1
--      | Lam i e1, Func a a1, Func b b1, typed-lam p1, typed-lam p2 => absurd (no-lam (i, e1, idp))
--      | App e1 e2, a, b, typed-app Qt p1 p2, typed-app Qt1 p3 p4 =>
--          \let
--            | ue1 => type-unique {e1} {Func Qt a} {Func Qt1 b} {c}
--                {\lam _x => no-con (_x.1, sub-app (inl _x.2))}
--                {{?}}
--                p1 p3
--            | ue2 => type-unique {e2} {Qt} {Qt1} {c}
--                {\lam _x => no-con (_x.1, sub-app (inr _x.2))}
--                {{?}}
--                p2 p4
--          \in (STDecSet.rmFunc ue1).2
  }

\func replace (e : Expr) (var-no : Nat) (to-expr : Expr) : Expr \elim e
  | Con n => Con n
  | Var n => if (n == var-no) to-expr (Var n)
  | Lam n e => if (n == var-no) (Lam n e) (Lam n (replace e var-no to-expr))
  | App e1 e2 => App (replace e1 var-no to-expr) (replace e2 var-no to-expr)
    \where {
      \func same-con-lam {e B : Expr} {i : Nat} (p : A-Eq e (Lam i B)) : \Sigma (B' : Expr) (j : Nat) (e = Lam j B') \elim e, p
        | Lam i1 e, a2lam-eq-base i2 new-i-B1 new-i-B2 a => (e, i1, idp)

      \func same-con-app {e P Q : Expr} (p : A-Eq e (App P Q)) : \Sigma (P' Q' : Expr) (e = App P' Q') \elim e, p
        | App e e1, a2app-eq a a1 => (e, e1, idp)

      \func same-con-app-lam {e P Q : Expr} {i : Nat} (p : A-Eq e (App (Lam i P) Q)) : \Sigma (P' Q' : Expr) (j : Nat) (e = App (Lam j P') Q') \elim e, p
        | App e e1, a2app-eq a a1 => \let (P', j, e=lam) => same-con-lam a \in (P', e1, j, pmap (\lam x => App x e1) e=lam)

      \func same-var-replace (e : Expr) (n : Nat) : replace e n (Var n) = e \elim e
        | Con n1 => idp
        | Var n1 => \case decideEq n1 n \as d \return if (decToBool d) (Var n) (Var n1) = Var n1 \with {
          | yes e => pmap Var (inv e)
          | no n2 => idp
        }
        | Lam n1 e => \case decideEq n1 n \as d \return if (decToBool d) (Lam n1 e) (Lam n1 (replace e n (Var n))) = Lam n1 e \with {
          | yes e' => idp
          | no n2 => pmap (Lam n1) (same-var-replace e n)
        }
        | App e1 e2 => pmap2 App (same-var-replace e1 n) (same-var-replace e2 n)

      \func neutral-replace (e x : Expr) (var-no : Nat) (p : Not (var-no in FV e)) : replace e var-no x = e \elim e, var-no, p
        | Con n, v, p => idp
        | Var n, v, p => \case decideEq n v \as d \return if {Expr} (decToBool d) x (Var n) = Var n \with {
          | yes e => absurd (p (isHead e))
          | no n1 => idp
        }
        | Lam n e, v, p => \case decideEq n v \as d \return if {Expr} (decToBool d) (Lam n e) (Lam n (replace e v x)) = Lam n e \with {
          | yes e => idp
          | no n1 => pmap (Lam n) (neutral-replace e x v (\lam i => p (removeAll.rmv-works2 v i n1)))
        }
        | App e1 e2, v, p => pmap2 App
            (neutral-replace e1 x v (\lam i => p (in.merge-works v (byLeft i))))
            (neutral-replace e2 x v (\lam i => p (in.merge-works v (byRight i))))
    }