\import Arith.Nat
\import Data.Bool
\import Paths
\import Paths.Meta
\import Set
\import calculus.Context
\import calculus.Types
\import math.utils

\data Expr_
  | c Nat
  | v Nat -- layer diff
  | \fixr 2 l Expr_
  | \infixl 6 @ Expr_ Expr_

  \where {
    \func app-decon {P1 Q1 P2 Q2 : Expr_} (p : P1 @ Q1 = P2 @ Q2) : \Sigma (P1 = P2) (Q1 = Q2) =>
      (
        pmap (\lam x => \case x \with {| c n => c 0 | v n => c 0 | l e => c 0| e @ e1 => e}) p,
        pmap (\lam x => \case x \with {| c n => c 0 | v n => c 0 | l e => c 0| e @ e1 => e1}) p
      )
  }

\data TypedExpr_ (e : Expr_) (t : Type_) (h : Nat) (c : Context_) \elim e, t
  | (c _), t => t-con
  | (v i), t => t-var (i-exist : Context_.typed-var-in-context (h_c h i, t) c = true)
  | (l B), tx ~> tB => t-lam (B-typed : TypedExpr_ B tB (suc h) (Context_.update-assump (h, tx) c))
  | P @ Q, tr => t-app (tq : Type_) (P-typed : TypedExpr_ P (tq ~> tr) h c) (Q-typed : TypedExpr_ Q tq h c)

  \where {
    \func lam-has-func-type {B : Expr_} {i : Nat} {t : Type_} {h : Nat} {c : Context_} (typed : TypedExpr_ (l B) t h c) :
      \Sigma (a b : Type_) (t = a ~> b)
      \elim t, typed
        | t1 ~> t2, t-lam _ => (t1, t2, idp)

    \func app-parts-types {P Q : Expr_} {t : Type_} {h : Nat} {c : Context_} (typed : TypedExpr_ (P @ Q) t h c) :
      \Sigma (a b : Type_) (TypedExpr_ P (a ~> b) h c) (TypedExpr_ Q a h c)
      \elim t, typed
        | Rt, t-app Qt typed typed1 => (Qt, Rt, typed, typed1)
  }


\func isFree (n cur_h : Nat) => nat_<=-dec.nat_<=_Bool cur_h n

-- (l B) A = B[0=A]
\func apply_ (B A : Expr_) : Expr_ => apply''_ B A 0
  \where {
    \func apply''_ (B A : Expr_) (cur_h : Nat) : Expr_ \elim B
      | c n => c n
      | v 0 => if (0 == cur_h) (shift+dh A cur_h 0) (v 0)
      | v (suc n) => if (suc n == cur_h) (shift+dh A cur_h 0) (if (isFree (suc n) cur_h) (v n) (v (suc n)))
      | l B => l (apply''_ B A (suc cur_h))
      | B1 @ B2 => apply''_ B1 A cur_h @ apply''_ B2 A cur_h

    \func shift+dh (e : Expr_) (dh : Nat) (cur_h : Nat) : Expr_ \elim e
      | c n => c n
      | v n => if (isFree n cur_h) (v (n Nat.+ dh)) (v n)
      | l e => l (shift+dh e dh (suc cur_h))
      | e1 @ e2 => shift+dh e1 dh cur_h @ shift+dh e2 dh cur_h

    \func shift-0=id {e : Expr_} {cur-h : Nat} : shift+dh e 0 cur-h = e \elim e
      | c n => idp
      | v n => \case isFree n cur-h \as d \return if d (v n) (v n) = v n \with {
        | false => idp
        | true => idp
      }
      | l e => pmap l shift-0=id
      | e1 @ e2 => pmap2 (@) shift-0=id shift-0=id

    \func trivial-apply {x : Expr_} : x = apply_ (v 0) x =>
      (
        rewrite apply_.shift-0=id idp
        : x = if (0 NatSemiring.== 0) (apply_.shift+dh x 0 0) (v 0)
      )

    \func trivial/=0-apply {x : Expr_} {n : Nat} : v n = apply_ (v (suc n)) x =>
      (
        idp
        : v n = if (suc n == 0) (apply_.shift+dh x 0 0) (if (isFree (suc n) 0) (v n) (v (suc n)))
      )
  }

