\import Arith.Nat
\import Data.Bool
\import Paths
\import Paths.Meta
\import Set
\import calculus.AlphaEq
\import calculus.AlphaEq2
\import calculus.Beta
\import calculus.Context
\import calculus.Types

\data Expr : \Set
  | Con Nat
  | Var Nat
  | Lam Nat Expr
  | App Expr Expr

\data TypedExpr (e : Expr) (t : SimpleType) (c : Context) \elim e, t, c
  | (Con _), t, c => typed-const
  | (Var i), t, c => typed-var (i-exists : Context.typed-var-in-context (i, t) c = true)
  | (Lam i B), (Func a b), c => typed-lam
    (b-typed      : TypedExpr B b (Context.update-assump (i, a) c))
  | (App P Q), t, c => typed-app
    (Qt : SimpleType)
    (p-typed : TypedExpr P (Func Qt t) c)
    (q-typed : TypedExpr Q Qt c)
  \where {
    \func lam-has-func-type {B : Expr} {i : Nat} {t : SimpleType} {c : Context} (typed : TypedExpr (Lam i B) t c) :
      \Sigma (a b : SimpleType) (t = Func a b)
      \elim t, typed
        | Func t1 t2, typed-lam typed => (t1, t2, idp)

    \func app-parts-types {P Q : Expr} {t : SimpleType} {c : Context} (typed : TypedExpr (App P Q) t c) :
      \Sigma (a b : SimpleType) (TypedExpr P (Func a b) c) (TypedExpr Q a c)
      \elim t, typed
        | Rt, typed-app Qt typed typed1 => (Qt, Rt, typed, typed1)
  }

\func replace (e : Expr) (var-no : Nat) (to-expr : Expr) : Expr \elim e
  | Con n => Con n
  | Var n => if (n == var-no) to-expr (Var n)
  | Lam n e => if (n == var-no) (Lam n e) (Lam n (replace e var-no to-expr))
  | App e1 e2 => App (replace e1 var-no to-expr) (replace e2 var-no to-expr)
    \where {
      \func same-con-lam {e B : Expr} {i : Nat} (p : A-Eq e (Lam i B)) : \Sigma (B' : Expr) (j : Nat) (e = Lam j B') \elim e, p
        | Lam i1 e, a2lam-eq-base i2 new-i-B1 new-i-B2 a => (e, i1, idp)

      \func same-con-app {e P Q : Expr} (p : A-Eq e (App P Q)) : \Sigma (P' Q' : Expr) (e = App P' Q') \elim e, p
        | App e e1, a2app-eq a a1 => (e, e1, idp)

      \func same-con-app-lam {e P Q : Expr} {i : Nat} (p : A-Eq e (App (Lam i P) Q)) : \Sigma (P' Q' : Expr) (j : Nat) (e = App (Lam j P') Q') \elim e, p
        | App e e1, a2app-eq a a1 => \let (P', j, e=lam) => same-con-lam a \in (P', e1, j, pmap (\lam x => App x e1) e=lam)
    }