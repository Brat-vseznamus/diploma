\import Arith.Nat
\import Data.Bool
\import Logic
\import Paths
\import Paths.Meta
\import Set
\import calculus.AlphaEq
\import calculus.Context
\import calculus.Types
\import math.utils

\data Expr : \Set
  | Con Nat
  | Var Nat
  | Lam Nat Expr
  | App Expr Expr

\data HeightExpr (h : Nat) (e : Expr) \elim h, e
  | 0, Con n => h-con
  | 0, Var n => h-var
  | suc n, Lam i B => h-lam (HeightExpr n B)
  | h, App P Q => h-app {hp hq : Nat} (h = max hp hq) (HeightExpr hp P) (HeightExpr hq Q)
  \where {
    \func height (e : Expr) : \Sigma (h : Nat) (HeightExpr h e) \elim e
      | Con n => (0, h-con)
      | Var n => (0, h-var)
      | Lam n e1 => \let | (h, p) => height e1 \in (suc h, h-lam p)
      | App e1 e2 => \let
        | (h1, p1) => height e1
        | (h2, p2) => height e2
        \in (max h1 h2, h-app idp p1 p2)
  }

\data SizedExpr (h w : Nat) (e : Expr) \elim h, w, e
  | h, 0, Con n => hw-con
  | h, 0, Var n => hw-var
  | h, 0, Lam i B => hw-lam (SizedExpr (suc h) 0 B)
  | h, (suc w), App P Q => hw-app (SizedExpr h w P) (SizedExpr h 0 Q)


\func repl-save-height {e e' : Expr} {from to h : Nat}
                       (r : Repl e e' from to) (he : HeightExpr h e) : HeightExpr h e' \elim e, e', h, r, he
  | Con n, Con n2, 0, repl-con p, h-con => h-con
  | Var n, Var n2, 0, repl-var-succ p p1, h-var => h-var
  | Var n, Var n2, 0, repl-var-fail n1 p, h-var => h-var
  | App P1 Q1, App P2 Q2, h, repl-app r1 r2, h-app p he1 he2 =>
    \let
      | r-save1 => repl-save-height r1 he1
      | r-save2 => repl-save-height r2 he2
    \in h-app p r-save1 r-save2
  | Lam _ B1, Lam _ B2, suc h, repl-lam-stps _ _ B1=B2, h-lam hB => h-lam (rewriteF B1=B2 hB)
  | Lam i e, Lam i2 e', suc h, repl-lam-cont p n r, h-lam he => h-lam (repl-save-height r he)

\func repl-save-size {e e' : Expr} {from to h w : Nat}
                       (r : Repl e e' from to) (se : SizedExpr h w e) : SizedExpr h w e' \elim e, e', h, w, r, se
  | Con n, Con n2, h, 0, repl-con p, hw-con => hw-con
  | Var n, Var n2, h, 0, repl-var-succ p p1, hw-var => hw-var
  | Var n, Var n2, h, 0, repl-var-fail n1 p, hw-var => hw-var
  | App e e1, App e' e'1, h, suc w, repl-app r1 r2, hw-app se1 se2 =>
    \let
      | r-save1 => repl-save-size r1 se1
      | r-save2 => repl-save-size r2 se2
    \in hw-app r-save1 r-save2
  | Lam i e, Lam i2 e', h, 0, repl-lam-stps _ _ B1=B2, hw-lam sB => hw-lam (rewriteF B1=B2 sB)
  | Lam i e, Lam i2 e', h, 0, repl-lam-cont p n r, hw-lam se => hw-lam (repl-save-size r se)

\func alpha-refl {e : Expr} {h : Nat} (he : HeightExpr h e) : A-Eq e e \elim e, h, he
  | Con n, 0, h-con => con-eq idp
  | Var n, 0, h-var => var-eq idp
  | Lam i e, suc h, h-lam he =>
    \let
      | rp => Repl.repl e i (common-new-var-no e e)
      | save => repl-save-height {e} {rp} {i} {common-new-var-no e e} {h} (Repl.provide e i (common-new-var-no e e)) he
    \in  A-Eq.lam-eq2 (alpha-refl {rp} {h} save)
  | App P Q, h, h-app p heP heQ => \case split-max p \with {
    | byLeft h=hp => app-eq {?} {?}
    | byRight h=hq => {?}
  }

\func alpha-refl2 {e : Expr} {h w : Nat} (se : SizedExpr h w e) : A-Eq e e \elim e, h, w, se
  | Con n, h, 0, hw-con => con-eq idp
  | Var n, h, 0, hw-var => var-eq idp
  | Lam i e, h, 0, hw-lam se =>
    \let
      | rp => Repl.repl e i (common-new-var-no e e)
      | save => repl-save-size {e} {rp} {i} {common-new-var-no e e} {suc h} {0} (Repl.provide e i (common-new-var-no e e)) se
    \in  A-Eq.lam-eq2 (alpha-refl2 {rp} {suc h} {0} save)
  | App e e1, h, suc w, hw-app se1 se2 => {?}


-- app-eq (alpha-refl he1) (alpha-refl he2)

\func replace (e : Expr) (v : Nat) (target : Expr) : Expr \elim e
  | Con n => Con n
  | Var n => if (n == v) target (Var n)
  | Lam n e => Lam n (if (n == v) e (replace e v target))
  | App e1 e2 => App (replace e1 v target) (replace e2 v target)

\data Repl (e e' : Expr) (from to : Nat) \elim e, e'
  | Con n1, Con n2  => repl-con (n1 = n2)
  | Var n1, Var n2 => repl-var-succ (n1 = from) (n2 = to)
  | Var n1, Var n2 => repl-var-fail (Not (n1 = from)) (n1 = n2)
  | App P1 Q1, App P2 Q2 => repl-app (Repl P1 P2 from to) (Repl Q1 Q2 from to)
  | Lam i1 B1, Lam i2 B2 => repl-lam-stps (i1 = i2) (i1 = from) (B1 = B2)
  | Lam i1 B1, Lam i2 B2 => repl-lam-cont (i1 = i2) (Not (i1 = from)) (Repl B1 B2 from to)
  \where {
    \func repl (e : Expr) (from to : Nat) : Expr \elim e
      | Con n => Con n
      | Var n => if (from == n) (Var to) (Var n)
      | Lam n e1 => if (from == n) (Lam n e1) (Lam n (repl e1 from to))
      | App e1 e2 => App (repl e1 from to) (repl e2 from to)


    \func provide2 (e : Expr) (from to : Nat) : \Sigma (e' : Expr) (Repl e e' from to) \elim e
      | Con n => (Con n, repl-con idp)
      | Var n => \let
        | vareq => \case decideEq from n \as p \return Repl (Var n) (if {Expr} (decToBool p) (Var to) (Var n)) from to \with {
          | yes e1 => repl-var-succ (inv e1) idp
          | no n1 => repl-var-fail (\lam p => n1 (inv p)) idp
        }
        \in (if (from == n) (Var to) (Var n), vareq)
      | Lam n e1 => \let
        | p-e1 => provide2 e1 from to
        | lameq => \case decideEq from n \as p \return Repl (Lam n e1) (if {Expr} (decToBool p) (Lam n e1) (Lam n p-e1.1)) from to \with {
          | yes e2 => repl-lam-stps idp (inv e2) idp
          | no n1 => repl-lam-cont idp (\lam p => n1 (inv p)) p-e1.2
        }
        \in (if (from == n) (Lam n e1) (Lam n p-e1.1), lameq)
      | App e1 e2 => \let
        | p-e1 => provide2 e1 from to
        | p-e2 => provide2 e2 from to
                     \in (App p-e1.1 p-e2.1, repl-app p-e1.2 p-e2.2)

    \func provide (e : Expr) (from to : Nat) : Repl e (repl e from to) from to \elim e
      | Con n => repl-con idp
      | Var n => \case decideEq from n \as p \return Repl (Var n) (if {Expr} (decToBool p) (Var to) (Var n)) from to \with {
        | yes e1 => repl-var-succ (inv e1) idp
        | no n1 => repl-var-fail (\lam p => n1 (inv p)) idp
      }
      | Lam n e1 => \case decideEq from n \as p \return Repl (Lam n e1) (if {Expr} (decToBool p) (Lam n e1) (Lam n (repl e1 from to))) from to \with {
        | yes e2 => repl-lam-stps idp (inv e2) idp
        | no n1 => repl-lam-cont idp (\lam p => n1 (inv p)) (provide e1 from to)
      }
      | App e1 e2 => repl-app (provide e1 from to) (provide e2 from to)

--    \func alpha-save3
--      {B1 B1' B2 B2' : Expr}
--      {i1 i2 t : Nat}
--      {is-new1 : NewVar t B1}
--      {is-new2 : NewVar t B2}
--      {b1-repl : Repl B1 B1' i1 t}
--      {b2-repl : Repl B2 B2' i2 t} : A-Eq B1' B2' \elim B1, B1', B2, B2', b1-repl, b2-repl
--
--    \func alpha-save-lam
--      {B1 B2 : Expr}
--      {i1 i2 : Nat}
--      {is-new : NewVar i2 B1}
--      (B-repl : Repl B1 B2 i1 i2) : A-Eq (Lam i1 B1) (Lam i2 B2) \elim B1, B2, B-repl
--      | Con n1, Con n2, repl-con p => A-Eq.lam-eq (con-eq p)
--      | Var n1, Var n2, repl-var-succ p p1 => \let
--        | vareq => \case decideEq i1 n1 \as p1, decideEq i2 n2 \as p2 \return A-Eq (if {Expr} (decToBool p1) (Var (common-new-var-no (Var n1) (Var n2))) (Var n1))
--            (if {Expr} (decToBool p2) (Var (common-new-var-no (Var n1) (Var n2))) (Var n2)) \with {
--          | yes e1, yes e2 => var-eq idp
--          | yes e1, no n => absurd (n (inv p1))
--          | no n, yes e1 => absurd (n (inv p))
--          | no n, no n3 => absurd (n (inv p))
--        }
--                                              \in A-Eq.lam-eq vareq
--      | Var n1, Var n2, repl-var-fail n1/=i1 n1=n2 => \let
--        | vareq => \case decideEq i1 n1 \as p1, decideEq i2 n2 \as p2 \return A-Eq (if {Expr} (decToBool p1) (Var (common-new-var-no (Var n1) (Var n2))) (Var n1))
--            (if {Expr} (decToBool p2) (Var (common-new-var-no (Var n1) (Var n2))) (Var n2)) \with {
--          | yes e1, yes e2 => var-eq idp
--          | yes e1, no n1 => absurd (n1/=i1 (inv e1))
--          | no n1, yes i2=n2 => \case is-new \with {
--            | nv n1<i2 => absurd (NatSemiring.<-irreflexive (rewriteF (inv (i2=n2 *> inv n1=n2)) n1<i2))
--          }
--          | no i1/=n1, no i2/=n2 => var-eq n1=n2
--        }
--                                             \in A-Eq.lam-eq vareq
--      | App B1 B2, App B3 B4, repl-app B-repl1 B-repl2 => A-Eq.lam-eq (
--          app-eq
--              {?}
--              {?}
--                                                                      )
--      | Lam i3 B1, Lam i4 B2, repl-lam-stps p p1 p2 => {?}
--      | Lam i3 B1, Lam i4 B2, repl-lam-cont p n B-repl => {?}

  }


\data TypedExpr (e : Expr) (t : SimpleType) (c : Context) \elim e, t, c
  | (Con _), t, c => typed-const
  | (Var i), t, c => typed-var (i-exists : Context.typed-var-in-context (i, t) c = true)
  | (Lam i B), (Func a b), c => typed-lam
    (b-exists      : TypedExpr B b (Context.add-assump (i, a) c))
    (i-is-not-free : Context.var-in-context i c = false)
  | (App P Q), t, c => typed-app
    (Qt : SimpleType)
    (p-typed : TypedExpr P (Func Qt t) c)
    (q-typed : TypedExpr Q Qt c)
