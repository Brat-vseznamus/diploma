\import Arith.Nat
\import Data.Bool
\import Data.Or
\import Logic
\import Paths
\import Paths.Meta
\import Set
\import calculus.AlphaEq2
\import calculus.Base
\import calculus.Beta
\import calculus.Context
\import calculus.SubTerm
\import calculus.Types
\import math.sets
\import math.utils

\func A => Base 0

\func \infixr 6 --> (a a' : SimpleType) => Func a a'

\func s1 : A --> (A --> A) = Func A (Func A A) => idp
\func s2 : (A --> A) --> A --> A = Func (Func A A) (Func A A) => idp


\data Set3 {T : \Type} (e1 e2 e3 : T) (e : T)
  | is1 (e = e1)
  | is2 (e = e2)
  | is3 (e = e3)

\func inS (e : SimpleType) => Set3 {SimpleType} A (A --> A) ((A --> A) --> A --> A) e

\func theorema1
  (e : Expr)
  (t : SimpleType)
  (c : Context)
  (nf : NormalForm e e)
  (typed : TypedExpr e t c)
  (t-inS : inS t)
  (no-con : \Pi (i : Nat) -> Not (SubTerm e (Con i)))
  (closed : FV e leq CV c)
  (each-var-typed : \Pi (i : Nat) (ti : SimpleType) (Context.typed-var-in-context (i, ti) c = true) -> inS ti) :
  \Pi (se : Expr) (sub : SubTerm e se) -> inS (SubTerm.type-subterm e se sub t c typed).1 \elim e
  | Con n => \lam se sub => \case sub \with {
    | sub-same p => absurd (no-con n (sub-same idp))
  }
  | Var n => \lam se sub => \case sub \as s \return inS (SubTerm.type-subterm (Var n) se s t c typed).1 \with {
    | sub-same p => t-inS
  }
  | Lam n e => \lam se sub => \case sub \as s, t \as t', typed \as typed' : TypedExpr (Lam n e) t' c, t-inS : inS t' \return inS (SubTerm.type-subterm (Lam n e) se s t' c typed').1 \with {
    | sub-lam s, Func a b, typed-lam typedl, t-inS' => \let
      | nfl : NormalForm e e => \case nf \with {
        | NormalForm.nf b1 n1 => NormalForm.nf (end A-Eq2.ref) (\lam (e', b-e') => n1 (Lam n e', beta-lam idp b-e'))
      }
      | no-conl : \Pi (i : Nat) -> Not (SubTerm e (Con i)) => \lam i s => (no-con i) (sub-lam s)
      | a-inSl : inS a => \case t-inS' \with {
        | is1 p => absurd (suc/=0 (pmap STDecSet.conNo p))
        | is2 p => \let (lft, rght) =>  STDecSet.rmFunc p \in is1 lft
        | is3 p => \let (lft, rght) =>  STDecSet.rmFunc p \in is2 lft
      }
      | b-inSl : inS b => \case t-inS' \with {
        | is1 p => absurd (suc/=0 (pmap STDecSet.conNo p))
        | is2 p => \let (lft, rght) => STDecSet.rmFunc p \in is1 rght
        | is3 p => \let (lft, rght) => STDecSet.rmFunc p \in is2 rght
      }
      | closedL : FV e leq CV (Context.update-assump (n, a) c) => ext-closed e n a c closed
      | var-ext : \Pi (i : Nat) (ti : SimpleType) (Context.typed-var-in-context (i, ti) (Context.update-assump (n, a) c) = true) -> inS ti =>
          var-ext-impl n a b a-inSl b-inSl c each-var-typed
      | rec => theorema1 e b (Context.update-assump (n, a) c) nfl typedl b-inSl no-conl closedL var-ext se s
                    \in rec
    | sub-same p, Func t' t'1, typed-lam typed', t-inS' => t-inS'
  }

  | App e1 e2 => \lam se sub => \case sub \as s, t \as t', typed \as typed' : TypedExpr (App e1 e2) t' c, t-inS : inS t' \return inS (SubTerm.type-subterm (App e1 e2) se s t' c typed').1 \with {
    | sub-app (inl a), t', typed-app Qt typed' typed'1, t-inS' =>
      \let
        | pt-inS => leftInS3 e1 e2 t' Qt c typed' typed'1 no-con nf each-var-typed
      \in theorema1
          e1
          (Func Qt t')
          c
          (NormalForm.nf (end A-Eq2.ref) (\lam (e, b-e) => \case nf \with {
            | NormalForm.nf b1 n => n (App e e2, beta-app-right b-e A-Eq2.ref)
          }))
          typed'
          pt-inS
          (\lam i s => no-con i (sub-app (inl s)))
          (decon-closed {App e1 e2} {e1} {e2} {c} {idp} closed).1
          each-var-typed
          se
          a
    | sub-app (inr b), t', typed-app Qt typed' typed'1, t-inS' =>
      \let
        | pt-inS => leftInS3 e1 e2 t' Qt c typed' typed'1 no-con nf each-var-typed
        | q-inS : inS Qt => \case pt-inS, t-inS' \with {
          | is1 p, _ => absurd (suc/=0 (pmap STDecSet.conNo p))
          | is2 p, is1 p1 => \let (eq1, eq2) => STDecSet.rmFunc p \in is1 eq1
          | is2 p, is2 p1 => \let (eq1, eq2) => STDecSet.rmFunc p \in absurd (suc/=0 (pmap STDecSet.conNo (inv p1 *> eq2)))
          | is2 p, is3 p1 => \let (eq1, eq2) => STDecSet.rmFunc p \in absurd (suc/=0 (pmap STDecSet.conNo (inv p1 *> eq2)))
          | is3 p, is1 p1 => \let (eq1, eq2) => STDecSet.rmFunc p \in absurd (suc/=0 (pmap STDecSet.conNo (inv eq2 *> p1)))
          | is3 p, is2 p1 => \let (eq1, eq2) => STDecSet.rmFunc p \in is2 eq1
          | is3 p, is3 p1 => \let (eq1, eq2) => STDecSet.rmFunc p \in absurd (suc/=0 (pmap STDecSet.conNo (STDecSet.rmFunc (inv p1 *> eq2)).1))
        }
      \in theorema1
          e2
          Qt
          c
          (NormalForm.nf (end A-Eq2.ref) (\lam (e, b-e) => \case nf \with {
            | NormalForm.nf b1 n => n (App e1 e, beta-app-left A-Eq2.ref b-e)
          }))
          typed'1
          q-inS
          (\lam i s => no-con i (sub-app (inr s)))
          (decon-closed {App e1 e2} {e1} {e2} {c} {idp} closed).2
          each-var-typed
          se
          b
    | sub-same p, t', typed-app Qt typed' typed'1, t-inS' => t-inS'
  }

  \where {
    \func lam-decon {t a b c d : SimpleType} (p1 : t = a --> b) (p2 : t = c --> d) : \Sigma (a = c) (b = d) =>
      STDecSet.rmFunc (inv p1 *> p2)

    \func decon-closed {e e1 e2 : Expr} {c : Context} {p : e = App e1 e2}
                       (closed : FV e leq CV c) :
      \Sigma (FV e1 leq CV c) (FV e2 leq CV c) \elim e, e1, e2, p, closed
      | App e1 e2, e3, e4, p, closed1 =>
        \let
          | name => Expr.app-decon p
          | mInC => leq.fromSet closed1
          | mW => in.merge-works {FV e1} {FV e2}
        \in
        (
          leq.inSet (\lam x i => mInC x (mW x (byLeft (rewrite name.1 i)))),
          leq.inSet (\lam x i => mInC x (mW x (byRight (rewrite name.2 i))))
        )
      | Con n, Con n1, Con n2, (), closed1
      | Con n, Var n1, Con n2, (), closed1
      | Con n, Lam n1 e1, Con n2, (), closed1
      | Con n, App e1 e2, Con n1, (), closed1
      | Var n, Con n1, Con n2, (), closed1
      | Var n, Var n1, Con n2, (), closed1
      | Var n, Lam n1 e1, Con n2, (), closed1
      | Var n, App e1 e2, Con n1, (), closed1
      | Lam n e, Con n1, Con n2, (), closed1
      | Lam n e, Var n1, Con n2, (), closed1


    \func ext-closed
      (e : Expr)
      (n : Nat)
      (a : SimpleType)
      (c : Context)
      (l : removeAll (FV e) n leq CV c)
      : FV e leq CV (Context.update-assump (n, a) c) =>
      \let
        | decL => leq.fromSet l
        | cvU : CV (Context.update-assump (n, a) c) seq (n :: CV c) => {?} -- TODO
        | inC1->C2 : \Pi (x : Nat) (x in (n :: CV c)) -> x in CV (Context.update-assump (n, a) c) => \case cvU \with {
          | seq-con l1 l2 => leq.fromSet l2
        }
      \in
        leq.inSet (\lam x i => \case decideEq n x \with {
          | yes e1 => inC1->C2 x (isHead e1)
          | no n1 => inC1->C2 x (inTail n1 (decL x (removeAll.rmv-works2 x i n1)))
        })

    \func var-ext-impl (n : Nat) (a b : SimpleType) (a-inS : inS a) (b-inS : inS b) (c : Context)
                       (each-var-typed : \Pi (i : Nat) (ti : SimpleType) (Context.typed-var-in-context (i, ti) c = true) -> inS ti) :
      \Pi (i : Nat) (ti : SimpleType) (Context.typed-var-in-context (i, ti) (Context.update-assump (n, a) c) = true) -> inS ti
    \elim c
      | empty => \lam i ti p => \case decideEq n i \as d1, decideEq a ti \as d2, p : if {Bool} (decToBool d1) (decToBool d2) false = true \with {
        | yes e, yes e1, p1 => rewriteF e1 a-inS
        | no n1, yes e, ()
      }
      | with (m, tm) c1 => \lam i ti p => \case
        decideEq m i \as d1,
        decideEq m n \as d2,
        decideEq tm ti \as d3,
        p : if {Bool} (decToBool d1) (if {SimpleType} (decToBool d2) a tm == ti) (Context.typed-var-in-context (i, ti) (if {Context} (decToBool d2) c1 (Context.update-assump (n, a) c1))) = true,
        (each-var-typed i ti) : \Pi (if {Bool} (decToBool d1) (decToBool d3) (Context.typed-var-in-context (i, ti) c1) = true) -> inS ti \with {
        | yes e, yes e1, yes e2, p1, _x => _x idp
        | yes e, yes e1, no n1, p1, _x => \let a=ti => ==->= {SimpleType} {STDecSet} p1 \in rewriteF a=ti a-inS
        | yes e, no n1, yes e1, p1, _x => _x idp
        | yes e, no n1, no n2, p1, _x => \let ti=tm => ==->= {SimpleType} {STDecSet} p1 \in absurd (n2 ti=tm)
        | no n1, yes e, yes e1, p1, _x => _x p1
        | no n1, yes e, no n2, p1, _x => _x p1
        | no n1, no n2, yes e, p1, _x => \case decideEq n i \with {
          | yes e1 => \case decideEq m m \as dm, decideEq tm tm \as dtm, (each-var-typed m tm) : (if {Bool} (decToBool dm) (decToBool dtm) (Context.typed-var-in-context (m, tm) c1) = true -> inS tm) \with {
            | yes e2, yes e3, _x1 => rewriteF e (_x1 idp)
            | yes e2, no n3, _x1 => absurd (n3 idp)
            | no n3, yes e2, _x1 => absurd (n3 idp)
            | no n3, no n4, _x1 => absurd (n3 idp)
          }
          | no n3 =>
            \let
              | n-check => neutral-check {n} {i} {c1} {a} {ti} n3
              | p2 => rewriteF n-check p1
            \in _x p2
        }
        | no n1, no n2, no n3, p1, _x => \case decideEq n i \with {
          | yes e1 => \let exact => get-after-update (rewriteF (inv e1) p1) \in rewriteF (inv exact) a-inS

          | no n3 =>
            \let
              | n-check => neutral-check {n} {i} {c1} {a} {ti} n3
              | p2 => rewriteF n-check p1
            \in _x p2
        }
      }

    \func neutral-check {n i : Nat} {c1 : Context} {tn ti : SimpleType}
                        (neq : Not (n = i)) :
      Context.typed-var-in-context (i, ti) (Context.update-assump (n, tn) c1) = Context.typed-var-in-context (i, ti) c1 =>
      {?}

    \func get-after-update {n : Nat} {ti b : SimpleType} {c1 : Context}
                           (p : Context.typed-var-in-context (n, ti) (Context.update-assump (n, b) c1) = true) :
      ti = b => {?}

    \func leftInS3
      (e1 e2 : Expr)
      (t Qt : SimpleType)
      (c : Context)
      (typedP : TypedExpr e1 (Func Qt t) c)
      (typedQ : TypedExpr e2 Qt c)
      (no-con : \Pi (i : Nat) -> Not (SubTerm (App e1 e2) (Con i)))
      (nf : NormalForm (App e1 e2) (App e1 e2))
      (each-var-typed : VarsTypedCorrectly c) : inS (Func Qt t) \elim e1
      | Con n => absurd (no-con n (sub-app (inl (sub-same idp))))
      | Var n => \case typedP \with {
        | typed-var i-exists => \let f-inS => each-var-typed n (Func Qt t) i-exists \in f-inS
      }
      | Lam n e1 => \case nf \with {
        | NormalForm.nf b n1 => absurd (n1 (replace e1 n e2, beta-repl-right idp))
      }
      | App P Q =>
        \let
          | rec => leftInS
              P Q
              (Func Qt t)
              c
              typedP
              (\lam i s => no-con i (sub-app (inl s)))
              (NormalForm.nf (end A-Eq2.ref) (\lam (app-red, app-red-b) => \case nf \with {
                | NormalForm.nf b n => n (App app-red e2, beta-app-right app-red-b A-Eq2.ref)
              }))
              each-var-typed
        \in \case rec \with {
          | (t',i,t1) => \case i, typedP \with {
            | is1 p, (TypedExpr.typed-app Qt2 tP tQ) => absurd (suc/=0 (pmap STDecSet.conNo p))
            | is2 p, (TypedExpr.typed-app Qt2 tP tQ) => absurd (suc/=0 (pmap STDecSet.conNo (STDecSet.rmFunc p).2))
            | is3 p, (TypedExpr.typed-app Qt2 tP tQ) =>
              \let
                | (lft, rght-tmp) => STDecSet.rmFunc p
              \in is2 rght-tmp
          }
        }


    \func leftInS
      (e1 e2 : Expr)
      (t : SimpleType)
      (c : Context)
      (typed : TypedExpr (App e1 e2) t c)
      (no-con : \Pi (i : Nat) -> Not (SubTerm (App e1 e2) (Con i)))
      (nf : NormalForm (App e1 e2) (App e1 e2))
      (each-var-typed : VarsTypedCorrectly c) :
      \Sigma (t' : SimpleType) (inS (Func t' t)) (TypedExpr e1 (Func t' t) c) \elim e1, typed
      | Con n, typed-app Qt typed1 typed2 => absurd (no-con n (sub-app (inl (sub-same idp))))
      | Var n, typed-app Qt typed1 typed2 => \case typed1 \with {
        | typed-var i-exists => \let f-inS => each-var-typed n (Func Qt t) i-exists \in (Qt, f-inS, typed1)
      }
      | Lam n e1, typed-app Qt typed1 typed2 => \case nf \with {
        | NormalForm.nf b n1 => absurd (n1 (replace e1 n e2, beta-repl-right idp))
      }
      | App P Q, typed-app Qt typed1 typed2 =>
        \let
          | rec => leftInS
              P Q
              (Func Qt t)
              c
              typed1
              (\lam i s => no-con i (sub-app (inl s)))
              (NormalForm.nf (end A-Eq2.ref) (\lam (app-red, app-red-b) => \case nf \with {
                | NormalForm.nf b n => n (App app-red e2, beta-app-right app-red-b A-Eq2.ref)
              }))
              each-var-typed
        \in \case rec \with {
          | (t',i,t1) => \case i, typed1 \with {
            | is1 p, (TypedExpr.typed-app Qt2 tP tQ) => absurd (suc/=0 (pmap STDecSet.conNo p))
            | is2 p, (TypedExpr.typed-app Qt2 tP tQ) => absurd (suc/=0 (pmap STDecSet.conNo (STDecSet.rmFunc p).2))
            | is3 p, (TypedExpr.typed-app Qt2 tP tQ) =>
              \let
                | (lft, rght-tmp) => STDecSet.rmFunc p
                | (mid, rght) => STDecSet.rmFunc rght-tmp
              \in (A, is2 (pmap (\lam s => Func A s) rght), rewriteF mid typed1)
          }
        }
  }

\type VarsTypedCorrectly (c : Context) => \Pi (i : Nat) (ti : SimpleType) (Context.typed-var-in-context (i, ti) c = true) -> inS ti
  
