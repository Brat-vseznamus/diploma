\import Data.Bool
\import Logic
\import calculus.Base
\import calculus.Context
\import calculus.SubTerm
\import calculus.Types

\func A => Base 0

\func \infixr 6 --> (a a' : SimpleType) => Func a a'

\func s1 : A --> (A --> A) = Func A (Func A A) => idp
\func s2 : (A --> A) --> A --> A = Func (Func A A) (Func A A) => idp


\data Set3 {T : \Type} (e1 e2 e3 : T) (e : T)
  | is1 (e = e1)
  | is2 (e = e2)
  | is3 (e = e3)

\func inS (e : SimpleType) => Set3 {SimpleType} A (A --> A) ((A --> A) --> A --> A) e

\func theorema1
  (e : Expr)
  (t : SimpleType)
  (c : Context)
  (nf : NormalForm e e)
  (typed : TypedExpr e t c)
  (t-inS : inS t)
  (no-con : \Pi (i : Nat) -> Not (SubTerm e (Con i)))
  (closed : FV e leq CV c = true)
  (each-var-typed : \Pi (i : Nat) (ti : SimpleType) (Context.typed-var-in-context (i, ti) c = true) -> inS ti) :
  \Pi (se : Expr) (sub : SubTerm e se) -> inS (SubTerm.type-subterm {e} {se} {sub} t c typed).1 =>
  \lam se sub => \case se \as s, sub \as sb : SubTerm e s \return inS (SubTerm.type-subterm {e} {s} {sb} t c typed).1 \with {
    | Con n, sub => absurd ((no-con n) sub)
    | Var n, var-sub => {?}
    | Lam n e1, sb => {?}
    | App e1 e2, sb => {?}
  }
  
