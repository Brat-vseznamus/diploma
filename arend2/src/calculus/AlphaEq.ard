\import Arith.Bool
\import Arith.Nat
\import Data.Bool
\import Data.Or
\import Function.Meta
\import Logic
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Set \hiding (#)
\import calculus.Base
\import calculus.Context
\import calculus.SubTerm
\import math.sets
\import math.utils

\func PRepl => Array (\Sigma Nat Nat Nat)

\data NV (i : Nat) (e : Expr)
  | not-in-FV (Not (i in FV e))

\func create-common-NV (e1 e2 : Expr) : \Sigma (i : Nat) (NV i e1) (NV i e2) =>
  \let
    | nv1 => create-NV e1
    | nv2 => create-NV e2
  \in (max (suc (create-NV.maxArg (FV e1))) (suc (create-NV.maxArg (FV e2))), {?}, {?})

\func create-NV (e : Expr) : \Sigma (i : Nat) (NV i e) =>
  \let
    | fv => FV e
  \in (
        suc (maxArg fv),
        not-in-FV $ if_greatest_then_not_in_l
                        (\lam x i =>
                            \let rec => maxArg-max fv
                            \in math.utils.<=-<-transitive (rec x i) id<suc)
      )
    \where {
      \func if_greatest_then_not_in_l {x : Nat} {l : Array Nat} (p : \Pi (e : Nat) (e in l) -> e < x) : Not (x in l) =>
        \case in.decideIn x l \with {
          | yes e1 => absurd (StrictPoset.<-irreflexive $ p x e1)
          | no n => n
        }

      \func maxArg (l : Array Nat) : Nat \elim l
        | nil => 0
        | a :: l => max a (maxArg l)

      \func maxArg-max (l : Array Nat) : \Pi (x : Nat) (x in l) -> x Preorder.<= maxArg l \elim l
        | nil => \lam x i => absurd $ in.emptyNil x i
        | a :: l => \lam x i => \case i \with {
          | isHead a=x => \let a<=maxl => (max.a_b<=max {a} {maxArg l}).1 \in Preorder.<=∘ (NatSemiring.=_<= (inv a=x)) a<=maxl
          | inTail a/=x i1 => \let | rec => maxArg-max l x i1 \in Preorder.<=∘ rec (max.a_b<=max {a} {maxArg l}).2
        }
    }

\func \infix 6 <-> (A B : \Type) => \Sigma (A -> B) (B -> A)

\func r1 {A B : \Prop} : (\Sigma (Not A) (Not B)) <-> Not (Or A B) =>
  (
    \lam _x o => \case o \with {
      | inl a => _x.1 a
      | inr b => _x.2 b
    },
    \lam n => (\lam a => n (inl a), \lam b => n (inr b))
  )

\func pmap3 {A B C D : \Type} (f : A -> B -> C -> D) {a a' : A} (p : a = a') {b b' : B} (q : b = b') {c c' : C} (n : c = c'): f a b c = f a' b' c'
  => path (\lam i => f (p @ i) (q @ i) (n @ i))

\data Xor (A B : \Prop)
  | xleft (a : A)
  | xright (na : Not A) (b : B)

\data DBVarImpl
  | free Nat
  | link Int

\data DBExpr
  | DBCon Nat
  | DBVar DBVarImpl
  | DBApp DBExpr DBExpr
  | DBLam DBExpr
  \where {
    \func toDBExpr (e : Expr) : DBExpr => toDBExpr-lemma e (\lam x _ => free x) 0
      \where {
        \func toDBExpr-lemma (e : Expr) (c : Nat -> Nat -> DBVarImpl) (h : Nat) : DBExpr \elim e
          | Con n => DBCon n
          | Var n => DBVar $ c n h
          | Lam n e1 => DBLam (toDBExpr-lemma e1 (\lam x h' => if (x == n) (link (h' Nat.- h)) (c n h')) (suc h))
          | App e1 e2 => DBApp (toDBExpr-lemma e1 c h) (toDBExpr-lemma e2 c h)
      }
  }

\data A-Eq5 (e1 e2 : Expr)
  | skelets-eq (DBExpr.toDBExpr e1 = DBExpr.toDBExpr e2)
  \where {
    \func ref {e : Expr} : A-Eq5 e e => skelets-eq (pmap DBExpr.toDBExpr idp)
    \func sym {e1 e2 : Expr} (p : A-Eq5 e1 e2) : A-Eq5 e2 e1 \elim p
      | skelets-eq p => skelets-eq (inv p)
    \func trans {e1 e2 e3 : Expr} (p1 : A-Eq5 e1 e2) (p2 : A-Eq5 e2 e3) : A-Eq5 e1 e3 \elim p1, p2
      | skelets-eq p, skelets-eq p1 => skelets-eq (p *> p1)
  }

\data A-Eq4 (e1 e2 : Expr) {n : Nat} (l1 l2 : Array Nat n) : \Set \elim e1, e2
  | (Con i), (Con j) => a4con-eq (p : i = j)
  | (Var i), (Var j) => a4var-eq (p : Xor (Merge (i, j) l1 l2) (i = j))
  | (App P1 Q1), (App P2 Q2) => a4app-eq (A-Eq4 P1 P2 l1 l2) (A-Eq4 Q1 Q2 l1 l2)
  | (Lam i1 B1), (Lam i2 B2) => a4lam-eq-base (A-Eq4 B1 B2 (i1 :: l1) (i2 :: l2))

  \where {
    \data Merge (p : \Sigma Nat Nat) (l1 l2 : Array Nat) \elim p, l1, l2
      | p, v1 :: l1, v2 :: l2 => found (v1 = p.1) (v2 = p.2)
      | p, v1 :: l1, v2 :: l2 => inTail (v1 /= p.1) (v2 /= p.2) (Merge p l1 l2)
      \where {
        \use \level levelProp {p : \Sigma Nat Nat} {l1 l2 : Array Nat} (rp1 rp2 : Merge p l1 l2) : rp1 = rp2 \elim p, l1, l2, rp1, rp2
          | p, v1 :: l3, v2 :: l4, found v1=p1 v2=p2, found v1=p1' v2=p2' => pmap2 found (Path.inProp v1=p1 v1=p1') (Path.inProp v2=p2 v2=p2')
          | p, v1 :: l3, v2 :: l4, found p1 p2, inTail _x _x1 rp2 => absurd (_x p1)
          | p, v1 :: l3, v2 :: l4, inTail _x _x1 rp1, found p1 p2 => absurd (_x p1)
          | p, v1 :: l3, v2 :: l4, inTail _x _x1 rp1, inTail _x2 _x3 rp2 => pmap3 inTail
              (Path.inProp _x _x2)
              (Path.inProp _x1 _x3)
              (levelProp rp1 rp2)

        \func decMerge {n : Nat} (p : \Sigma Nat Nat) (l1 l2 : Array Nat n) : Dec (Merge p l1 l2) => {?}

        \func sym {i j : Nat} {l1 l2 : Array Nat} (p : Merge (i, j) l1 l2) : Merge (j, i) l2 l1 \elim l1, l2, p
          | n1 :: l3, n2 :: l4, found p1 p2 => found p2 p1
          | n1 :: l3, n2 :: l4, inTail _x _x1 p1 => inTail (\lam p => _x1 p) (\lam p => _x p) (sym p1)

        \func trans {i j k : Nat} {l1 l2 l3 : Array Nat} (p1 : Merge (i, j) l1 l2) (p2 : Merge (j, k) l2 l3) : Merge (i, k) l1 l3 \elim l1, l2, l3, p1, p2
          | n1 :: l3, n2 :: l4, n3 :: l5, found p1 p2, found p3 p4 => found p1 p4
          | n1 :: l3, n2 :: l4, n3 :: l5, found p1 p2, inTail _x _x1 p3 => absurd (_x p2)
          | n1 :: l3, n2 :: l4, n3 :: l5, inTail _x _x1 p1, found p2 p3 => absurd (_x1 p2)
          | n1 :: l3, n2 :: l4, n3 :: l5, inTail _x _x1 p1, inTail _x2 _x3 p2 => inTail _x _x3 (trans p1 p2)

--        \func position {n : Nat} {l1 l2 : Array Nat} (p : \Sigma Nat Nat) (m : Merge p l1 l2) : Nat \elim n, l1, l2, m
--          | n, n1 :: l3, n2 :: l4, found p1 p2 => 0
--          | suc n, n1 :: l3, n2 :: l4, inTail _x _x1 m => suc (position p m)
      }

    \func ref {e : Expr} {n : Nat} {l : Array Nat n} : A-Eq4 e e l l \elim e
      | Con n1 => a4con-eq idp
      | Var n1 => a4var-eq (\case Merge.decMerge (n1, n1) l l \with {
        | yes e => xleft e
        | no n2 => xright n2 idp
      })
      | Lam n1 e => a4lam-eq-base ref
      | App e3 e4 => a4app-eq ref ref

    \func sym {e1 e2 : Expr} {n : Nat} {l1 l2 : Array Nat n} (p : A-Eq4 e1 e2 l1 l2) : A-Eq4 e2 e1 l2 l1 \elim e1, e2, p
      | Con i, Con j, a4con-eq p => a4con-eq (inv p)
      | Var i, Var j, a4var-eq p => \case p \with {
        | xleft a => a4var-eq (xleft (Merge.sym a))
        | xright na b => a4var-eq (xright (\lam m => na (Merge.sym m)) (inv b))
      }
      | App e3 e4, App e5 e6, a4app-eq p1 p2 => a4app-eq (sym p1) (sym p2)
      | Lam i1 e3, Lam i2 e4, a4lam-eq-base p => a4lam-eq-base (sym p)

    \func trans {e1 e2 e3 : Expr} {n : Nat} {l1 l2 l3 : Array Nat n} (p1 : A-Eq4 e1 e2 l1 l2) (p2 : A-Eq4 e2 e3 l2 l3) : A-Eq4 e1 e3 l1 l3 \elim e1, e2, e3, p1, p2
      | Con i, Con i1, Con j, a4con-eq p, a4con-eq p1 => a4con-eq (p *> p1)
      | Var i, Var i1, Var j, a4var-eq p, a4var-eq p1 => a4var-eq (\case p, p1 \with {
        | xleft a, xleft a1 => xleft $ Merge.trans a a1
        | xleft a, xright na b => \case Merge.decMerge (i, j) l1 l3 \with {
          | yes e => xleft e
          | no n1 => {?}
        }
        | xright na b, xleft a => {?}
        | xright na b, xright na1 b1 => xright (\lam m => {?}) (b *> b1)
      })
      | App e3 e4, App e5 e6, App e7 e8, a4app-eq p1 p2, a4app-eq p3 p4 => a4app-eq (trans p1 p3) (trans p2 p4)
      | Lam i1 e3, Lam i2 e4, Lam i3 e5, a4lam-eq-base p1, a4lam-eq-base p2 => a4lam-eq-base (trans p1 p2)
  }
