\import Arith.Nat
\import Data.Bool
\import Data.Maybe
\import Function.Meta ($)
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set
\import calculus.Base
\import math.utils

\func maxVar (e : Expr) : Nat \elim e
  | Con n => 0
  | Var n => n
  | Lam n e1 => max n (maxVar e1)
  | App e1 e2 => max (maxVar e1) (maxVar e2)


\data NewVar (i : Nat) (e : Expr)
  | nv (maxVar e < i)
  \where {
    \func ext-newVar (i j : Nat) (B : Expr) (nj : NewVar j B) : NewVar (max (suc i) j) (Lam i B) \elim nj
      | nv maxB<j => nv (max.max-monotone id<suc maxB<j)
  }

\func create-newvar (e : Expr) : NewVar (suc (maxVar e)) e =>
  nv (id<suc {maxVar e})

\func common-new-var-no (e1 e2 : Expr) : Nat => suc (max (maxVar e1) (maxVar e2))
    \where {
      \func sym {e1 e2 : Expr} : common-new-var-no e1 e2 = common-new-var-no e2 e1 =>
        pmap suc (max.max-sym (maxVar e1) (maxVar e2))
    }

\func common-new-var (e1 e2 : Expr) :
  \Sigma
    (NewVar (common-new-var-no e1 e2) e1)
    (NewVar (common-new-var-no e1 e2) e2) =>
  \let
    | m1 => maxVar e1
    | m2 => maxVar e2
  \in
    \case create-newvar e1, create-newvar e2 \with {
      | nv m1<sm1, nv m2<sm2 => \let
        | (m1<=max, m2<=max) => max.a_b<=max {m1} {m2}
        | sm1<=smax => suc<=suc m1<=max
        | sm2<=smax => suc<=suc m2<=max
        \in (
          nv (<-<=-transitive m1<sm1 sm1<=smax),
          nv (<-<=-transitive m2<sm2 sm2<=smax)
        )
    }

\data A-Eq2 (e1 e2 : Expr) (f1 f2 : Nat -> Nat) \elim e1, e2
  | (Con i), (Con j) => a2con-eq (p : i = j)
  | (Var i), (Var j) => a2var-eq (p : f1 i = f2 j)
  | (App P1 Q1), (App P2 Q2) => a2app-eq (A-Eq2 P1 P2 f1 f2) (A-Eq2 Q1 Q2 f1 f2)
  | (Lam i1 B1), (Lam i2 B2) => a2lam-eq-base
    (i : Nat)
    (new-i-B1 : NewVar i B1)
    (new-i-B2 : NewVar i B2)
    (A-Eq2 B1 B2 (extMod f1 i1 i) (extMod f2 i2 i))
  \where {
    \func extMod (f : Nat -> Nat) (from to : Nat) : Nat -> Nat =>
      \lam x => if (x == from) to (f x)

    \func ref {e : Expr} {f : Nat -> Nat} : A-Eq2 e e f f \elim e
      | Con n => a2con-eq idp
      | Var n => a2var-eq (pmap f idp)
      | Lam n e =>
        \let
          | newVar => suc (maxVar e)
          | isNewVar => create-newvar e
        \in  a2lam-eq-base newVar isNewVar isNewVar ref
      | App P Q => a2app-eq ref ref

    \func sym {e1 e2 : Expr} {f1 f2 : Nat -> Nat} (same : A-Eq2 e1 e2 f1 f2) : A-Eq2 e2 e1 f2 f1 \elim e1, e2, same
      | Con i, Con j, a2con-eq p => a2con-eq (inv p)
      | Var i, Var j, a2var-eq p => a2var-eq (inv p)
      | App P1 Q1, App P2 Q2, a2app-eq same1 same2 =>
        a2app-eq (sym {P1} {P2} {f1} {f2} same1) (sym {Q1} {Q2} {f1} {f2} same2)
      | Lam i1 B1, Lam i2 B2, a2lam-eq-base i new-i-B1 new-i-B2 same =>
        a2lam-eq-base
            i
            new-i-B2
            new-i-B1
            (sym {B1} {B2} {extMod f1 i1 i} {extMod f2 i2 i} same)

    \func trans {e1 e2 e3 : Expr} {f1 f2 f3 : Nat -> Nat}
                (p12 : A-Eq2 e1 e2 f1 f2) (p23 : A-Eq2 e2 e3 f2 f3) : A-Eq2 e1 e3 f1 f3 \elim e1, e2, e3, p12, p23
      | Con i, Con j, Con k, a2con-eq p, a2con-eq p1 => a2con-eq (p *> p1)
      | Var i, Var j, Var k, a2var-eq p, a2var-eq p1 => a2var-eq (p *> p1)
      | App P1 Q1, App P2 Q2, App P3 Q3, a2app-eq p12 q12, a2app-eq p23 q23 =>
        a2app-eq
            (trans {P1} {P2} {P3} p12 p23)
            (trans {Q1} {Q2} {Q3} q12 q23)
      | Lam i1 B1, Lam i2 B2, Lam i3 B3,
        a2lam-eq-base i12 new-i1-B1 new-i1-B2 p12,
        a2lam-eq-base i23 new-i2-B2 new-i2-B3 p23 => a2lam-eq-base {?} {?} {?} {?}

  }


-- TODO change lam-eq to NewVar
\data A-Eq (e1 e2 : Expr) \elim e1, e2
  | (Con i), (Con j) => con-eq (p : i = j)
  | (Var i), (Var j) => var-eq (p : i = j)
  | (App P1 Q1), (App P2 Q2) => app-eq (A-Eq P1 P2) (A-Eq Q1 Q2)
  | (Lam i1 B1), (Lam i2 B2) => lam-eq-base
      (i : Nat)
      (new-i-B1 : NewVar i B1)
      (new-i-B2 : NewVar i B2)
      {B1' B2' : Expr}
      {new-B1 : Repl B1 B1' i1 i}
      {new-B2 : Repl B2 B2' i2 i}
      (A-Eq B1' B2')

  \where {
    \func lam-eq
      {B1 B2 : Expr}
      {i1 i2 : Nat}
      (p : A-Eq (Repl.provide2 B1 i1 (common-new-var-no B1 B2)).1 (Repl.provide2 B2 i2 (common-new-var-no B1 B2)).1)
      : A-Eq (Lam i1 B1) (Lam i2 B2) =>
      \let
        | (B1', rB1') => Repl.provide2 B1 i1 (common-new-var-no B1 B2)
        | (B2', rB2') => Repl.provide2 B2 i2 (common-new-var-no B1 B2)
      \in
      lam-eq-base
        (common-new-var-no B1 B2)
        (common-new-var B1 B2).1
        (common-new-var B1 B2).2
        {B1'}
        {B2'}
        {rB1'}
        {rB2'}
        p

    \func lam-eq2
      {B1 B2 : Expr}
      {i1 i2 : Nat}
      (p : A-Eq (Repl.repl B1 i1 (common-new-var-no B1 B2)) (Repl.repl B2 i2 (common-new-var-no B1 B2)))
      : A-Eq (Lam i1 B1) (Lam i2 B2) =>
      lam-eq-base
          (common-new-var-no B1 B2)
          (common-new-var B1 B2).1
          (common-new-var B1 B2).2
          {Repl.repl B1 i1 (common-new-var-no B1 B2)}
          {Repl.repl B2 i2 (common-new-var-no B1 B2)}
          {Repl.provide B1 i1 (common-new-var-no B1 B2)}
          {Repl.provide B2 i2 (common-new-var-no B1 B2)}
          p

    \func refl {e : Expr} : A-Eq e e => {?}

    \func sym {e1 e2 : Expr} (p : A-Eq e1 e2) : A-Eq e2 e1 \elim e1, e2, p
      | Con i, Con j, con-eq p => con-eq (inv p)
      | Var i, Var j, var-eq p => var-eq (inv p)
      | App e1 e2, App e3 e4, app-eq p1 p2 => app-eq (sym p1) (sym p2)
      | Lam i1 e1, Lam i2 e2, lam-eq-base i ne1 ne2 p => {?}

    \func trans {e1 e2 e3 : Expr} (p1 : A-Eq e1 e2) (p2 : A-Eq e2 e3) : A-Eq e1 e3 \elim e1, e2, e3, p1, p2
      | Con i, Con j, Con k, con-eq i=j, con-eq j=k => con-eq (i=j *> j=k)
      | Var i, Var j, Var k, var-eq i=j, var-eq j=k => var-eq (i=j *> j=k)
      | App P1 Q1, App P2 Q2, App P3 Q3, app-eq p1=p2 q1=q2, app-eq p2=p3 q2=q3 =>
          app-eq (trans p1=p2 p2=p3) (trans q1=q2 q2=q3)
      | Lam i B1,
        Lam j B2,
        Lam k B3,
        lam-eq-base n1 new-B1-1 new-B2-1 p1,
        lam-eq-base n2 new-B2-2 new-B3-2 p2 => {?}
  }
