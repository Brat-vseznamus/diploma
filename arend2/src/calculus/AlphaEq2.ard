\import Arith.Nat
\import Data.Bool
\import Data.Maybe
\import Function.Meta ($)
\import Logic
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set
\import calculus.Base
\import math.utils

\func maxVar2 (e : Expr) (f : Nat -> Nat) : Nat \elim e
  | Con n => 0
  | Var n => f n
  | Lam n e1 => max n (maxVar2 e1 f)
  | App e1 e2 => max (maxVar2 e1 f) (maxVar2 e2 f)


\data NewVar2 (i : Nat) (e : Expr) (f : Nat -> Nat)
  | nv (maxVar2 e f < i)
  \where {
    \func neq {i : Nat} {e : Expr} {f : Nat -> Nat} (nv : NewVar2 i e f) : maxVar2 e f < i \elim nv | nv _x => _x
    \func ext-newVar (i j : Nat) (B : Expr) (f : Nat -> Nat) (nj : NewVar2 j B f) : NewVar2 (max (suc i) j) (Lam i B) f \elim nj
      | nv maxB<j => nv (max.max-monotone id<suc maxB<j)
  }

\func create-newvar (e : Expr) (f : Nat -> Nat) : NewVar2 (suc (maxVar2 e f)) e f =>
  nv (id<suc {maxVar2 e f})

\func common-new-var-no (e1 e2 : Expr) (f1 f2 : Nat -> Nat) : Nat => suc (max (maxVar2 e1 f1) (maxVar2 e2 f2))
  \where {
    \func sym {e1 e2 : Expr} {f1 f2 : Nat -> Nat} : common-new-var-no e1 e2 f1 f2 = common-new-var-no e2 e1 f2 f1 =>
      pmap suc (max.max-sym (maxVar2 e1 f1) (maxVar2 e2 f2))
  }

\func common-new-var (e1 e2 : Expr) (f1 f2 : Nat -> Nat) :
  \Sigma
    (NewVar2 (common-new-var-no e1 e2 f1 f2) e1 f1)
    (NewVar2 (common-new-var-no e1 e2 f1 f2) e2 f2) =>
  \let
    | m1 => maxVar2 e1 f1
    | m2 => maxVar2 e2 f2
  \in
    \case create-newvar e1 f1, create-newvar e2 f2 \with {
      | nv m1<sm1, nv m2<sm2 => \let
        | (m1<=max, m2<=max) => max.a_b<=max {m1} {m2}
        | sm1<=smax => suc<=suc m1<=max
        | sm2<=smax => suc<=suc m2<=max
                                \in (
          nv (<-<=-transitive m1<sm1 sm1<=smax),
          nv (<-<=-transitive m2<sm2 sm2<=smax)
        )
    }

\data A-Eq2 (e1 e2 : Expr) (f1 f2 : Nat -> Nat) : \Set \elim e1, e2
  | (Con i), (Con j) => a2con-eq (p : i = j)
  | (Var i), (Var j) => a2var-eq (p : f1 i = f2 j)
  | (App P1 Q1), (App P2 Q2) => a2app-eq (A-Eq2 P1 P2 f1 f2) (A-Eq2 Q1 Q2 f1 f2)
  | (Lam i1 B1), (Lam i2 B2) => a2lam-eq-base
    (i : Nat)
    (new-i-B1 : NewVar2 i B1 f1)
    (new-i-B2 : NewVar2 i B2 f2)
    (A-Eq2 B1 B2 (extMod f1 i1 i) (extMod f2 i2 i))
  \where {
    \func a2-lam-eq {i1 i2 : Nat} {B1 B2 : Expr} {f1 f2 : Nat -> Nat}
          (p : A-Eq2 B1 B2 (extMod f1 i1 $ common-new-var-no B1 B2 f1 f2) (extMod f2 i2 $ common-new-var-no B1 B2 f1 f2))
                    : A-Eq2 (Lam i1 B1) (Lam i2 B2) f1 f2 =>
      a2lam-eq-base
          (common-new-var-no B1 B2 f1 f2)
          (common-new-var B1 B2 f1 f2).1
          (common-new-var B1 B2 f1 f2).2
          p

    \func extMod (f : Nat -> Nat) (from to : Nat) : Nat -> Nat =>
      \lam x => if (x == from) to (f x)

    \func ref {e : Expr} {f : Nat -> Nat} : A-Eq2 e e f f \elim e
      | Con n => a2con-eq idp
      | Var n => a2var-eq (pmap f idp)
      | Lam n e =>
        \let
          | newVar => suc (maxVar2 e f)
          | isNewVar => create-newvar e f
        \in  a2lam-eq-base newVar isNewVar isNewVar ref
      | App P Q => a2app-eq ref ref

    \func sym {e1 e2 : Expr} {f1 f2 : Nat -> Nat} (same : A-Eq2 e1 e2 f1 f2) : A-Eq2 e2 e1 f2 f1 \elim e1, e2, same
      | Con i, Con j, a2con-eq p => a2con-eq (inv p)
      | Var i, Var j, a2var-eq p => a2var-eq (inv p)
      | App P1 Q1, App P2 Q2, a2app-eq same1 same2 =>
        a2app-eq (sym {P1} {P2} {f1} {f2} same1) (sym {Q1} {Q2} {f1} {f2} same2)
      | Lam i1 B1, Lam i2 B2, a2lam-eq-base i new-i-B1 new-i-B2 same =>
        a2lam-eq-base
            i
            new-i-B2
            new-i-B1
            (sym {B1} {B2} {extMod f1 i1 i} {extMod f2 i2 i} same)

    \func trans {e1 e2 e3 : Expr} {f1 f2 f3 : Nat -> Nat}
                (p12 : A-Eq2 e1 e2 f1 f2) (p23 : A-Eq2 e2 e3 f2 f3) : A-Eq2 e1 e3 f1 f3 \elim e1, e2, e3, p12, p23
      | Con i, Con j, Con k, a2con-eq p, a2con-eq p1 => a2con-eq (p *> p1)
      | Var i, Var j, Var k, a2var-eq p, a2var-eq p1 => a2var-eq (p *> p1)
      | App P1 Q1, App P2 Q2, App P3 Q3, a2app-eq p12 q12, a2app-eq p23 q23 =>
        a2app-eq
            (trans {P1} {P2} {P3} p12 p23)
            (trans {Q1} {Q2} {Q3} q12 q23)
      | Lam i1 B1, Lam i2 B2, Lam i3 B3,
      a2lam-eq-base i12 new-i1-B1 new-i1-B2 p12,
      a2lam-eq-base i23 new-i2-B2 new-i2-B3 p23 => 
        \let
          | newVar => max i12 i23
          | new-B1 => \case new-i1-B1 \return NewVar2 newVar B1 f1 \with {
            | nv _x => nv (math.utils.<-<=-transitive _x (max.a_b<=max {i12} {i23}).1)
          }
          | new-B2-1 => \case new-i1-B2 \return NewVar2 newVar B2 f2 \with {
            | nv _x => nv (math.utils.<-<=-transitive _x (max.a_b<=max {i12} {i23}).1)
          }
          | new-B3 => \case new-i2-B3 \return NewVar2 newVar B3 f3 \with {
            | nv _x => nv (math.utils.<-<=-transitive _x (max.a_b<=max {i12} {i23}).2)
          }

        \in a2lam-eq-base newVar new-B1 new-B3 $
        trans
            (upper {B1} {B2} {i1} {i2} {f1} {f2} {i12} {newVar} {new-i1-B1} {new-i1-B2} p12 (max.a_b<=max {i12} {i23}).1)
            (upper {B2} {B3} {i2} {i3} {f2} {f3} {i23} {newVar} {new-i2-B2} {new-i2-B3} p23 (max.a_b<=max {i12} {i23}).2)

      \where {
        \func upper
          {e1 e2 : Expr}
          {i1 i2 : Nat}
          {f1 f2 : Nat -> Nat}
          {i j : Nat}
          {p1 : NewVar2 i e1 f1}
          {p2 : NewVar2 i e2 f2}
          (same-with-rep : A-Eq2 e1 e2 (extMod f1 i1 i) (extMod f2 i2 i))
          (i<=j : i <= j) :
          A-Eq2 e1 e2 (extMod f1 i1 j) (extMod f2 i2 j) \elim e1, e2, same-with-rep
          | Con i3, Con j1, a2con-eq p => a2con-eq p
          | Var n, Var m, a2var-eq p => a2var-eq (upper-lemma1 f1 i1 j i n f2 i2 m p {p1} {p2})
          | App e3 e4, App e5 e6, a2app-eq same-with-rep1 same-with-rep2 => a2app-eq
              (upper {e3} {e5} {i1} {i2} {f1} {f2} {i} {j}
                  {(upper-lemma2 f1 i {App e3 e4} {e3} {e4} {idp} p1).1}
                  {(upper-lemma2 f2 i {App e5 e6} {e5} {e6} {idp} p2).1} same-with-rep1 i<=j
              )
              (upper {e4} {e6} {i1} {i2} {f1} {f2} {i} {j}
                  {(upper-lemma2 f1 i {App e3 e4} {e3} {e4} {idp} p1).2}
                  {(upper-lemma2 f2 i {App e5 e6} {e5} {e6} {idp} p2).2} same-with-rep2 i<=j
              )
          -- TODO
          | Lam i3 e3, Lam i4 e4, a2lam-eq-base i5 new-i-B1 new-i-B2 same-with-rep => {?}
          \where {
            \func upper-lemma1 (f1 : Nat -> Nat) (i1 j i n : Nat) (f2 : Nat -> Nat) (i2 m : Nat)
                               (p : extMod f1 i1 i n = extMod f2 i2 i m)
                               {p1 : NewVar2 i (Var n) f1}
                               {p2 : NewVar2 i (Var m) f2} : extMod f1 i1 j n = extMod f2 i2 j m =>
              (parse f1 i1 j n *> upper-lemma1-1 n i1 j i f1 m i2 f2 ((parse f1 i1 i n *> p) *> (inv $ parse f2 i2 i m)) {p1} {p2}) *> inv (parse f2 i2 j m)

            \func upper-lemma1-1 (n i1 j i : Nat) (f1 : Nat -> Nat) (m i2 : Nat) (f2 : Nat -> Nat)
                                 (p : if (n == i1) i (f1 n) = if (m == i2) i (f2 m))
                                 {p1 : NewVar2 i (Var n) f1}
                                 {p2 : NewVar2 i (Var m) f2} :
              if (n == i1) j (f1 n) = if (m == i2) j (f2 m) =>
              \let
                | f1_n<i => NewVar2.neq p1
                | f2_m<i => NewVar2.neq p2
              \in
              \case decideEq n i1 \as p1, decideEq m i2 \as p2 \return if (decToBool p1) j (f1 n) = if (decToBool p2) j (f2 m) \with {
                | yes e, yes e3 => idp
                | yes e, no n1 => \let x => rewriteF (/=->/== n1) $ rewriteF (=->== e) p
                                  \in absurd $ NatSemiring.<-irreflexive {f2 m} (rewriteF x f2_m<i)
                | no n1, yes e => \let x => rewriteF (/=->/== n1) $ rewriteF (=->== e) p
                                  \in absurd $ NatSemiring.<-irreflexive {f1 n} (rewriteF (inv x) f1_n<i)
                | no n1, no n2 => rewriteF (/=->/== n2) $ rewriteF (/=->/== n1) p
              }

            \func upper-lemma2 (f : Nat -> Nat) (i : Nat) {e1 P1 Q1 : Expr} {p : e1 = App P1 Q1} (nv1 : NewVar2 i e1 f) :
              \Sigma (NewVar2 i P1 f) (NewVar2 i Q1 f) => \case nv1 \with {
              | nv i-e1 =>
                \let
                  | i1-e1 => rewriteF p i-e1
                  | i1-P1 => math.utils.<=-<-transitive (max.a_b<=max {maxVar2 P1 f} {maxVar2 Q1 f}).1 i1-e1
                  | i1-Q1 => math.utils.<=-<-transitive (max.a_b<=max {maxVar2 P1 f} {maxVar2 Q1 f}).2 i1-e1
                \in (nv i1-P1, nv i1-Q1)
            }
          }
      }

      \func parse (f : Nat -> Nat) (i j : Nat) (n : Nat) : extMod f i j n = if (n == i) j (f n) => idp
  }
