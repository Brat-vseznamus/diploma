\import Arith.Nat
\import Data.Bool
\import Function.Meta ($)
\import Logic
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set
\import calculus.Base
\import math.utils

\import Paths.Meta
\import calculus.Base

\func idNat (x : Nat) => x
\func idNat=id {x : Nat} : idNat x = x => idp

\func A-Eq (e1 e2 : Expr) => A-Eq2 e1 e2 idNat idNat

\func maxVar2 (e : Expr) (f : Nat -> Nat) : Nat \elim e
  | Con n => 0
  | Var n => f n
  | Lam n e1 => max n (maxVar2 e1 (A-Eq2.extMod f n n))
  | App e1 e2 => max (maxVar2 e1 f) (maxVar2 e2 f)
  \where {
    \func mod->apply {e : Expr} {f : Nat -> Nat} : maxVar2 e f = maxVar2 (A-Eq2.apply f e) idNat \elim e
      | Con n => idp
      | Var n => idp
      | Lam n e => \let funRed : idNat = A-Eq2.extMod idNat n n => f=g (\lam x => \case decideEq x n \as d \return x = if (decToBool d) n x \with {
        | yes e1 => e1
        | no n1 => idp
      }) \in pmap2 max idp (rewriteF funRed (mod->apply {e} {A-Eq2.extMod f n n}))
      | App e1 e2 =>
        \let
          | r1 => mod->apply {e1} {f}
          | r2 => mod->apply {e2} {f}
        \in pmap2 max r1 r2


    \func f=g {f g : Nat -> Nat} (p : \Pi (x : Nat) -> f x = g x) : f = g => path (\lam i n => p n @ i)
  }


\data NewVar2 (i : Nat) (e : Expr) (f : Nat -> Nat)
  | nv (maxVar2 e f < i)
  \where {
    \func neq {i : Nat} {e : Expr} {f : Nat -> Nat} (nv : NewVar2 i e f) : maxVar2 e f < i \elim nv | nv _x => _x
--    \func ext-newVar (i j : Nat) (B : Expr) (f : Nat -> Nat) (nj : NewVar2 j B f) : NewVar2 (max (suc i) j) (Lam i B) f \elim nj
--      | nv maxB<j => nv (max.max-monotone id<suc maxB<j)
  }

\func create-newvar (e : Expr) (f : Nat -> Nat) : NewVar2 (suc (maxVar2 e f)) e f =>
  nv (id<suc {maxVar2 e f})

\func common-new-var-no (e1 e2 : Expr) (f1 f2 : Nat -> Nat) : Nat => suc (max (maxVar2 e1 f1) (maxVar2 e2 f2))
  \where {
    \func sym {e1 e2 : Expr} {f1 f2 : Nat -> Nat} : common-new-var-no e1 e2 f1 f2 = common-new-var-no e2 e1 f2 f1 =>
      pmap suc (max.max-sym (maxVar2 e1 f1) (maxVar2 e2 f2))
  }

\func common-new-var (e1 e2 : Expr) (f1 f2 : Nat -> Nat) :
  \Sigma
    (NewVar2 (common-new-var-no e1 e2 f1 f2) e1 f1)
    (NewVar2 (common-new-var-no e1 e2 f1 f2) e2 f2) =>
  \let
    | m1 => maxVar2 e1 f1
    | m2 => maxVar2 e2 f2
  \in
    \case create-newvar e1 f1, create-newvar e2 f2 \with {
      | nv m1<sm1, nv m2<sm2 => \let
        | (m1<=max, m2<=max) => max.a_b<=max {m1} {m2}
        | sm1<=smax => suc<=suc m1<=max
        | sm2<=smax => suc<=suc m2<=max
                                \in (
          nv (<-<=-transitive m1<sm1 sm1<=smax),
          nv (<-<=-transitive m2<sm2 sm2<=smax)
        )
    }

\data A-Eq2 (e1 e2 : Expr) (f1 f2 : Nat -> Nat) : \Set \elim e1, e2
  | (Con i), (Con j) => a2con-eq (p : i = j)
  | (Var i), (Var j) => a2var-eq (p : f1 i = f2 j)
  | (App P1 Q1), (App P2 Q2) => a2app-eq (A-Eq2 P1 P2 f1 f2) (A-Eq2 Q1 Q2 f1 f2)
  | (Lam i1 B1), (Lam i2 B2) => a2lam-eq-base
    (i : Nat)
    (new-i-B1 : NewVar2 i B1 f1)
    (new-i-B2 : NewVar2 i B2 f2)
    (A-Eq2 B1 B2 (extMod f1 i1 i) (extMod f2 i2 i))
  \where {
    \func apply (f : Nat -> Nat) (e : Expr) : Expr \elim e
      | Con n => Con n
      | Var n => Var (f n)
      | Lam n e => Lam n (apply (extMod f n n) e)
      | App e3 e4 => App (apply f e3) (apply f e4)

    \func mod->apply {f g : Nat -> Nat} {e1 e2 : Expr} (p : A-Eq2 e1 e2 f g) : A-Eq (apply f e1) (apply g e2) \elim e1, e2, p
      | Con i, Con j, a2con-eq p => a2con-eq p
      | Var i, Var j, a2var-eq p => a2var-eq p
      | App e3 e4, App e5 e6, a2app-eq p1 p2 =>  a2app-eq (mod->apply p1) (mod->apply p2)
      | Lam i1 e3, Lam i2 e4, a2lam-eq-base i new-i-B1 new-i-B2 p =>
        \let
          | rec => mod->apply p
          | b1' => nv (rewriteF maxVar2.mod->apply (NewVar2.neq new-i-B1))
        \in
          a2lam-eq-base i {?} {?} {?}

    \func eq->a-eq {e1 e2 : Expr} {f : Nat -> Nat} (p : e1 = e2) : A-Eq2 e1 e2 f f \elim e1, e2, p
      | Con n, Con n1, p => a2con-eq (pmap (\lam y => \case y \with {
        | Con n2 => n2
        | _ => 1
      }) p)
      | Var n, Var n1, p => a2var-eq (pmap (\lam y => \case y \with {
        | Var n2 => f n2
        | _ => 1
      }) p)
      | Lam n e3, Lam n1 e4, p =>
        \let
          | n=n1 => pmap (\lam y => \case y \with {
              | Lam n_ e_ => n_
              | _ => 1
            }) p
          | e3=e4 => pmap (\lam y => \case y \with {
            | Lam n_ e_ => e_
            | _ => Con 0
          }) p
        \in rewrite e3=e4 (rewrite n=n1 A-Eq2.ref)
      | App e3 e4, App e5 e6, p => \let
        | e3=e5 => pmap (\lam y => \case y \with {
          | App e_1 e_2 => e_1
          | _ => Con 0
        }) p
        | e4=e6 => pmap (\lam y => \case y \with {
          | App e_1 e_2 => e_2
          | _ => Con 0
        }) p
                                   \in a2app-eq (eq->a-eq e3=e5) (eq->a-eq e4=e6)

    \func a2neutral-to-mod {e1 e2 : Expr} {f : Nat -> Nat}
      (eq : A-Eq2 e1 e2 idNat idNat) : A-Eq2 e1 e2 f f \elim e1, e2, eq
      | Con i, Con j, a2con-eq p => a2con-eq p
      | Var i, Var j, a2var-eq p => a2var-eq (pmap f p)
      | App e3 e4, App e5 e6, a2app-eq eq1 eq2 => a2app-eq (a2neutral-to-mod eq1) (a2neutral-to-mod eq2)
      | Lam i1 e3, Lam i2 e4, a2lam-eq-base i new-i-B1 new-i-B2 eq => a2lam-eq-base {?} {?} {?} {?}

    \func a2lam-eq {f1 f2 : Nat -> Nat} {i1 i2 : Nat} {B1 B2 : Expr}
         (p : A-Eq2 B1 B2
            (extMod f1 i1 $ common-new-var-no B1 B2 f1 f2)
            (extMod f2 i2 $ common-new-var-no B1 B2 f1 f2)
         ) : A-Eq2 (Lam i1 B1) (Lam i2 B2) f1 f2 => a2lam-eq-base (common-new-var-no B1 B2 f1 f2)
              (common-new-var B1 B2 f1 f2).1
              (common-new-var B1 B2 f1 f2).2
              p

    \func extMod (f : Nat -> Nat) (from to : Nat) : Nat -> Nat =>
      \lam x => if (x == from) to (f x)

    \func ref {e : Expr} {f : Nat -> Nat} : A-Eq2 e e f f \elim e
      | Con n => a2con-eq idp
      | Var n => a2var-eq (pmap f idp)
      | Lam n e =>
        \let
          | newVar => suc (maxVar2 e f)
          | isNewVar => create-newvar e f
        \in  a2lam-eq-base newVar isNewVar isNewVar ref
      | App P Q => a2app-eq ref ref

    \func sym {e1 e2 : Expr} {f1 f2 : Nat -> Nat} (same : A-Eq2 e1 e2 f1 f2) : A-Eq2 e2 e1 f2 f1 \elim e1, e2, same
      | Con i, Con j, a2con-eq p => a2con-eq (inv p)
      | Var i, Var j, a2var-eq p => a2var-eq (inv p)
      | App P1 Q1, App P2 Q2, a2app-eq same1 same2 =>
        a2app-eq (sym {P1} {P2} {f1} {f2} same1) (sym {Q1} {Q2} {f1} {f2} same2)
      | Lam i1 B1, Lam i2 B2, a2lam-eq-base i new-i-B1 new-i-B2 same =>
        a2lam-eq-base
            i
            new-i-B2
            new-i-B1
            (sym {B1} {B2} {extMod f1 i1 i} {extMod f2 i2 i} same)

    \func trans {e1 e2 e3 : Expr} {f1 f2 f3 : Nat -> Nat}
                (p12 : A-Eq2 e1 e2 f1 f2) (p23 : A-Eq2 e2 e3 f2 f3) : A-Eq2 e1 e3 f1 f3 \elim e1, e2, e3, p12, p23
      | Con i, Con j, Con k, a2con-eq p, a2con-eq p1 => a2con-eq (p *> p1)
      | Var i, Var j, Var k, a2var-eq p, a2var-eq p1 => a2var-eq (p *> p1)
      | App P1 Q1, App P2 Q2, App P3 Q3, a2app-eq p12 q12, a2app-eq p23 q23 =>
        a2app-eq
            (trans {P1} {P2} {P3} p12 p23)
            (trans {Q1} {Q2} {Q3} q12 q23)
      | Lam i1 B1, Lam i2 B2, Lam i3 B3,
      a2lam-eq-base i12 new-i1-B1 new-i1-B2 p12,
      a2lam-eq-base i23 new-i2-B2 new-i2-B3 p23 => 
        \let
          | newVar => max i12 i23
          | new-B1 => \case new-i1-B1 \return NewVar2 newVar B1 f1 \with {
            | nv _x => nv (math.utils.<-<=-transitive _x (max.a_b<=max {i12} {i23}).1)
          }
          | new-B2-1 => \case new-i1-B2 \return NewVar2 newVar B2 f2 \with {
            | nv _x => nv (math.utils.<-<=-transitive _x (max.a_b<=max {i12} {i23}).1)
          }
          | new-B3 => \case new-i2-B3 \return NewVar2 newVar B3 f3 \with {
            | nv _x => nv (math.utils.<-<=-transitive _x (max.a_b<=max {i12} {i23}).2)
          }

        \in a2lam-eq-base newVar new-B1 new-B3 $
        trans
            (upper {B1} {B2} {i1} {i2} {f1} {f2} {i12} {newVar} {new-i1-B1} {new-i1-B2} p12 (max.a_b<=max {i12} {i23}).1)
            (upper {B2} {B3} {i2} {i3} {f2} {f3} {i23} {newVar} {new-i2-B2} {new-i2-B3} p23 (max.a_b<=max {i12} {i23}).2)

      \where {
        \func upper
          {e1 e2 : Expr}
          {i1 i2 : Nat}
          {f1 f2 : Nat -> Nat}
          {i j : Nat}
          {p1 : NewVar2 i e1 f1}
          {p2 : NewVar2 i e2 f2}
          (same-with-rep : A-Eq2 e1 e2 (extMod f1 i1 i) (extMod f2 i2 i))
          (i<=j : i <= j) :
          A-Eq2 e1 e2 (extMod f1 i1 j) (extMod f2 i2 j) \elim e1, e2, same-with-rep
          | Con i3, Con j1, a2con-eq p => a2con-eq p
          | Var n, Var m, a2var-eq p => a2var-eq (upper-lemma1 f1 i1 j i n f2 i2 m p {p1} {p2})
          | App e3 e4, App e5 e6, a2app-eq same-with-rep1 same-with-rep2 => a2app-eq
              (upper {e3} {e5} {i1} {i2} {f1} {f2} {i} {j}
                  {(upper-lemma2 f1 i {App e3 e4} {e3} {e4} {idp} p1).1}
                  {(upper-lemma2 f2 i {App e5 e6} {e5} {e6} {idp} p2).1} same-with-rep1 i<=j
              )
              (upper {e4} {e6} {i1} {i2} {f1} {f2} {i} {j}
                  {(upper-lemma2 f1 i {App e3 e4} {e3} {e4} {idp} p1).2}
                  {(upper-lemma2 f2 i {App e5 e6} {e5} {e6} {idp} p2).2} same-with-rep2 i<=j
              )
          -- TODO
          | Lam i3 e3, Lam i4 e4, a2lam-eq-base i5 new-i-B1 new-i-B2 same-with-rep => {?}
          \where {
            \func upper-lemma1 (f1 : Nat -> Nat) (i1 j i n : Nat) (f2 : Nat -> Nat) (i2 m : Nat)
                               (p : extMod f1 i1 i n = extMod f2 i2 i m)
                               {p1 : NewVar2 i (Var n) f1}
                               {p2 : NewVar2 i (Var m) f2} : extMod f1 i1 j n = extMod f2 i2 j m =>
              (parse f1 i1 j n *> upper-lemma1-1 n i1 j i f1 m i2 f2 ((parse f1 i1 i n *> p) *> (inv $ parse f2 i2 i m)) {p1} {p2}) *> inv (parse f2 i2 j m)

            \func upper-lemma1-1 (n i1 j i : Nat) (f1 : Nat -> Nat) (m i2 : Nat) (f2 : Nat -> Nat)
                                 (p : if (n == i1) i (f1 n) = if (m == i2) i (f2 m))
                                 {p1 : NewVar2 i (Var n) f1}
                                 {p2 : NewVar2 i (Var m) f2} :
              if (n == i1) j (f1 n) = if (m == i2) j (f2 m) =>
              \let
                | f1_n<i => NewVar2.neq p1
                | f2_m<i => NewVar2.neq p2
              \in
              \case decideEq n i1 \as p1, decideEq m i2 \as p2 \return if (decToBool p1) j (f1 n) = if (decToBool p2) j (f2 m) \with {
                | yes e, yes e3 => idp
                | yes e, no n1 => \let x => rewriteF (/=->/== n1) $ rewriteF (=->== e) p
                                  \in absurd $ NatSemiring.<-irreflexive {f2 m} (rewriteF x f2_m<i)
                | no n1, yes e => \let x => rewriteF (/=->/== n1) $ rewriteF (=->== e) p
                                  \in absurd $ NatSemiring.<-irreflexive {f1 n} (rewriteF (inv x) f1_n<i)
                | no n1, no n2 => rewriteF (/=->/== n2) $ rewriteF (/=->/== n1) p
              }

            \func upper-lemma2 (f : Nat -> Nat) (i : Nat) {e1 P1 Q1 : Expr} {p : e1 = App P1 Q1} (nv1 : NewVar2 i e1 f) :
              \Sigma (NewVar2 i P1 f) (NewVar2 i Q1 f) => \case nv1 \with {
              | nv i-e1 =>
                \let
                  | i1-e1 => rewriteF p i-e1
                  | i1-P1 => math.utils.<=-<-transitive (max.a_b<=max {maxVar2 P1 f} {maxVar2 Q1 f}).1 i1-e1
                  | i1-Q1 => math.utils.<=-<-transitive (max.a_b<=max {maxVar2 P1 f} {maxVar2 Q1 f}).2 i1-e1
                \in (nv i1-P1, nv i1-Q1)
            }
          }
      }

      \func parse (f : Nat -> Nat) (i j : Nat) (n : Nat) : extMod f i j n = if (n == i) j (f n) => idp
  }
