\import Arith.Nat
\import Data.Bool
\import Data.Maybe
\import Function.Meta ($)
\import Logic
\import Order.LinearOrder
\import Paths
\import Paths.Meta
\import Set
\import calculus.AlphaEq
\import calculus.AlphaEq2
\import calculus.Base
\import calculus.Beta
\import calculus.Context
\import math.sets

\open Nat

\type Repr (T : \Type) => \Pi (e : T) -> Expr

\func K-Args-Fun (A : \Type) (k : Nat) : \Type \elim k
  | 0 => A
  | suc k => A -> (K-Args-Fun A k)

\data K-Args (A : \Type) (k : Nat) \elim k
  | 0 => arg-empty
  | suc k => arg-con (a : A) (K-Args A k)

\func map {A B : \Type} {k : Nat} (f : A -> B) (as : K-Args A k) : K-Args B k \elim k, as
  | 0, arg-empty => arg-empty
  | suc k, arg-con a as => arg-con (f a) (map f as)

\func \infix 6 <- {A : \Type} {k : Nat} (f : K-Args-Fun A k) (args : K-Args A k) : A \elim k, f, args
  | 0, f, arg-empty => f
  | suc k, f, arg-con a args => f a <- args


\func K-App {k : Nat} (E : Expr) : K-Args-Fun Expr k \elim k
  | 0 => E
  | suc k => \lam (a : Expr) => K-App (App E a)


\func repeat (n : Nat) (f : Expr) (x : Expr) : Expr \elim n
  | 0 => x
  | suc n => App f (repeat n f x)
  \where {
    \func repeat-linear-+ {f x : Expr} (n m : Nat) : repeat n f (repeat m f x) = repeat (n Nat.+ m) f x \elim n, m
      | 0, 0 => idp
      | 0, suc m => idp
      | suc n, 0 => idp
      | suc n, suc m =>
        \let
          | m+1rec : App f (repeat m f x) = repeat (m Nat.+ 1) f x => repeat-linear-+ 1 m
          | n+m+1rec :  repeat n f (App f (repeat m f x)) = repeat (n Nat.+ suc m) f x => repeat-linear-+ n (suc m)
        \in
          pmap (App f) n+m+1rec

    \func repeat-linear-* {n m : Nat} : Beta-Eq (repeat n (Lam 2 (repeat m (Var 0) (Var 2))) (Var 1)) (repeat (n Nat.* m) (Var 0) (Var 1)) \elim n, m
      | 0, 0 => a-eq A-Eq2.ref
      | 0, suc m => a-eq (A-Eq2.eq->a-eq (inv (pmap (\lam x => repeat x (Var 0) (Var 1)) (NatSemiring.zro_*-left {m})))) -- (rewrite NatSemiring.zro_*-left idp)
      | suc n, 0 => chain (repeat n (Lam 2 (Var 2)) (Var 1)) (one-step-left (beta-repl-right idp)) (repeat-linear-*-lemma n)
      | suc n, suc m => chain (App (Var 0) (repeat m (Var 0) (repeat n (Lam 2 (repeat (suc m) (Var 0) (Var 2))) (Var 1))))
          (one-step-left (beta-repl-right (pmap (App (Var 0)) (inv $ repeat.right-neutral' {0} {2} {\lam p => suc/=0 (pmap pred (inv p))} m (repeat n (Lam 2 (App (Var 0) (repeat m (Var 0) (Var 2)))) (Var 1))))))
          (Beta-Eq.app-save-beta-eq-right
              (\let x => repeat-save-beta-eq {Var 0} m (repeat-linear-* {n} {suc m}) \in
                chain (repeat m (Var 0) (repeat (n Nat.* m Nat.+ n) (Var 0) (Var 1)))
                    x
                    (a-eq (A-Eq2.eq->a-eq (rewriteF (repeat-linear-*-math-lemma m n : m Nat.+ (n Nat.* m Nat.+ n) = suc n Nat.* m Nat.+ n) (repeat-linear-+ m (n Nat.* m Nat.+ n)))))
              )
          )
      \where {
        \func repeat-linear-*-lemma (n : Nat) : Beta-Eq (repeat n (Lam 2 (Var 2)) (Var 1)) (Var 1) \elim n
          | 0 => a-eq A-Eq2.ref
          | suc n => chain (repeat n (Lam 2 (Var 2)) (Var 1)) (one-step-left (beta-repl-right idp)) (repeat-linear-*-lemma n)

        \func repeat-linear-*-math-lemma (m n : Nat) : m Nat.+ (n Nat.* m Nat.+ n) = suc n Nat.* m Nat.+ n =>
          rewrite (inv NatSemiring.+-assoc)
              (rewrite (NatSemiring.+-comm {m} {n * m})
                  (rewrite
                      (rewrite (NatSemiring.*-comm {suc n} {m})
                          (rewrite (NatSemiring.*-comm {n} {m}) idp) : suc n * m = n * m + m)
                      idp
                  )
              )
      }

    \func repeat-linear-*' {x y z : Nat} {x/=z : Not (x = z)} {n m : Nat} : Beta-Eq (repeat n (Lam z (repeat m (Var x) (Var z))) (Var y)) (repeat (n Nat.* m) (Var x) (Var y)) \elim n, m
      | 0, 0 => a-eq A-Eq2.ref
      | 0, suc m => a-eq (A-Eq2.eq->a-eq (rewrite NatSemiring.zro_*-left idp))
      | suc n, 0 => chain (repeat n (Lam z (Var z)) (Var y))
          (one-step-left (beta-repl-right (\case decideEq z z \as d \return repeat n (Lam z (Var z)) (Var y) = if {Expr} (decToBool d) (repeat n (Lam z (Var z)) (Var y)) (Var z) \with {
            | yes e => idp
            | no n1 => absurd (n1 idp)
          })))
          (repeat-linear-*-lemma {x} {y} {z} n)
      | suc n, suc m =>
        chain (App (Var x) (repeat m (Var x) (repeat n (Lam z (repeat (suc m) (Var x) (Var z))) (Var y))))
            (one-step-left (beta-repl-right (\case decideEq x z \as d \return   App (Var x) (repeat m (Var x) (repeat n (Lam z (App (Var x) (repeat m (Var x) (Var z)))) (Var y))) = App (if {Expr} (decToBool d) (repeat n (Lam z (App (Var x) (repeat m (Var x) (Var z)))) (Var y)) (Var x))
                                                                                                                                                                                         (replace (repeat m (Var x) (Var z)) z (repeat n (Lam z (App (Var x) (repeat m (Var x) (Var z)))) (Var y))) \with {
              | yes e => absurd (x/=z e)
              | no n1 => pmap (App (Var x)) (inv $ repeat.right-neutral' {x} {z} {x/=z} m (repeat n (Lam z (App (Var x) (repeat m (Var x) (Var z)))) (Var y)))
            })))
            (Beta-Eq.app-save-beta-eq-right
                (\let r => repeat-save-beta-eq {Var x} m (repeat-linear-*' {x} {y} {z} {x/=z} {n} {suc m}) \in
                  chain (repeat m (Var x) (repeat (n Nat.* m Nat.+ n) (Var x) (Var y)))
                      r
                      (a-eq (A-Eq2.eq->a-eq (rewriteF (repeat-linear-*-math-lemma m n : m Nat.+ (n Nat.* m Nat.+ n) = suc n Nat.* m Nat.+ n) (repeat-linear-+ m (n Nat.* m Nat.+ n)))))
                )
            )
      \where {
        \func repeat-linear-*-lemma {x y z : Nat} (n : Nat) : Beta-Eq (repeat n (Lam z (Var z)) (Var y)) (Var y) \elim n
          | 0 => a-eq A-Eq2.ref
          | suc n => chain (repeat n (Lam z (Var z)) (Var y)) (one-step-left (beta-repl-right (\case decideEq z z \as d \return repeat n (Lam z (Var z)) (Var y) = if {Expr} (decToBool d) (repeat n (Lam z (Var z)) (Var y)) (Var z) \with {
            | yes e => idp
            | no n1 => absurd (n1 idp)
          }))) (repeat-linear-*-lemma {x} {y} {z} n)

        \func repeat-linear-*-math-lemma (m n : Nat) : m Nat.+ (n Nat.* m Nat.+ n) = suc n Nat.* m Nat.+ n =>
          rewrite (inv NatSemiring.+-assoc)
              (rewrite (NatSemiring.+-comm {m} {n * m})
                  (rewrite
                      (rewrite (NatSemiring.*-comm {suc n} {m})
                          (rewrite (NatSemiring.*-comm {n} {m}) idp) : suc n * m = n * m + m)
                      idp
                  )
              )
      }

    \func repeat-linear-*2 {x y z : Nat} {x/=z : Not (x = z)} {n m : Nat} : Beta-Eq (Lam x $ Lam y $ repeat n (Lam z (repeat m (Var x) (Var z))) (Var y)) (Lam x $ Lam y $ repeat (n Nat.* m) (Var x) (Var y)) \elim n, m
      | 0, 0 => a-eq A-Eq2.ref
      | 0, suc m => a-eq (A-Eq2.eq->a-eq (rewrite NatSemiring.zro_*-left idp))
      | suc n, 0 => chain (Lam x $ Lam y $ repeat n (Lam z (Var z)) (Var y))
          (one-step-left (bred-lam idp (bred-lam idp (beta-repl-right (\case decideEq z z \as d \return repeat n (Lam z (Var z)) (Var y) = if {Expr} (decToBool d) (repeat n (Lam z (Var z)) (Var y)) (Var z) \with {
                  | yes e => idp
                  | no n1 => absurd (n1 idp)
          })))))
          (repeat-linear-*-lemma2 {x} {y} {z} n)
      | suc n, suc m =>
        chain (Lam x $ Lam y $ App (Var x) (repeat m (Var x) (repeat n (Lam z (repeat (suc m) (Var x) (Var z))) (Var y))))
            (one-step-left (bred-lam idp (bred-lam idp (beta-repl-right (\case decideEq x z \as d \return   App (Var x) (repeat m (Var x) (repeat n (Lam z (App (Var x) (repeat m (Var x) (Var z)))) (Var y))) = App (if {Expr} (decToBool d) (repeat n (Lam z (App (Var x) (repeat m (Var x) (Var z)))) (Var y)) (Var x))
                                                                                                                                                                                         (replace (repeat m (Var x) (Var z)) z (repeat n (Lam z (App (Var x) (repeat m (Var x) (Var z)))) (Var y))) \with {
              | yes e => absurd (x/=z e)
              | no n1 => pmap (App (Var x)) (inv $ repeat.right-neutral' {x} {z} {x/=z} m (repeat n (Lam z (App (Var x) (repeat m (Var x) (Var z)))) (Var y)))
            })))))
            (\let r => repeat-save-beta-eq {Var x} m (repeat-linear-*' {x} {y} {z} {x/=z} {n} {suc m}) \in
              chain (Lam x $ Lam y $ repeat m (Var x) (repeat (n Nat.* m Nat.+ n) (Var x) (Var y)))
                  {?} -- r
                  {?} -- (a-eq (A-Eq2.eq->a-eq (rewriteF (repeat-linear-*-math-lemma m n : m Nat.+ (n Nat.* m Nat.+ n) = suc n Nat.* m Nat.+ n) (repeat-linear-+ m (n Nat.* m Nat.+ n)))))
            )

      \where {
        \func repeat-linear-*-lemma2 {x y z : Nat} (n : Nat) : Beta-Eq (Lam x $ Lam y $ repeat n (Lam z (Var z)) (Var y)) (Lam x $ Lam y $ Var y) \elim n
          | 0 => a-eq A-Eq2.ref
          | suc n => chain (Lam x $ Lam y $ repeat n (Lam z (Var z)) (Var y)) (one-step-left (bred-lam idp (bred-lam idp (beta-repl-right (\case decideEq z z \as d \return repeat n (Lam z (Var z)) (Var y) = if {Expr} (decToBool d) (repeat n (Lam z (Var z)) (Var y)) (Var z) \with {
            | yes e => idp
            | no n1 => absurd (n1 idp)
          }))))) (repeat-linear-*-lemma2 {x} {y} {z} n)

        \func repeat-linear-*-math-lemma (m n : Nat) : m Nat.+ (n Nat.* m Nat.+ n) = suc n Nat.* m Nat.+ n =>
          rewrite (inv NatSemiring.+-assoc)
              (rewrite (NatSemiring.+-comm {m} {n * m})
                  (rewrite
                      (rewrite (NatSemiring.*-comm {suc n} {m})
                          (rewrite (NatSemiring.*-comm {n} {m}) idp) : suc n * m = n * m + m)
                      idp
                  )
              )
      }

    \func repeat-save-beta-eq {f : Expr} {x1 x2 : Expr} (n : Nat) (bx1-x2 : Beta-Eq x1 x2) : Beta-Eq (repeat n f x1) (repeat n f x2) \elim n
      | 0 => bx1-x2
      | suc n => Beta-Eq.app-save-beta-eq-right (repeat-save-beta-eq n bx1-x2)

    \func fx-onlyFreeVars {f x : Expr} (n : Nat) : FV (repeat n f x) leq mergeUnique (FV f) (FV x) \elim n
      | 0 => leq.inSet (\lam x1 i => in.merge-works {FV f} {FV x} x1 (byRight i))
      | suc n => leq.inSet (\lam x1 i =>
          \let
            | orIn => in.merge-works2 x1 i
            | rec => fx-onlyFreeVars {f} {x} n
          \in
            \case orIn \with {
              | byLeft a => in.merge-works {FV f} {FV x} x1 (byLeft a)
              | byRight b => leq.fromSet rec x1 b
            }
          )
    \func left-neutral {l r : Nat} {l/=r : Not (l = r)} (n v : Nat) : replace (repeat n (Var l) (Var r)) l (Var v) = repeat n (Var v) (Var r) \elim n
      | 0 => \case decideEq r l \as d \return if (decToBool d) (Var v) (Var r) = Var r \with {
        | yes e => absurd $ l/=r (inv e)
        | no n => idp
      }
      | suc n => \case decideEq l l \as d \return App (if {Expr} (decToBool d) (Var v) (Var l)) (replace (repeat n (Var l) (Var r)) l (Var v)) = App (Var v) (repeat n (Var v) (Var r)) \with {
        | yes e => pmap (App (Var v)) (left-neutral {l} {r} {l/=r} n v)
        | no n => absurd $ n idp
      }

    \func left-neutral' {l r : Nat} {l/=r : Not (l = r)} (n : Nat) (e : Expr) : replace (repeat n (Var l) (Var r)) l e = repeat n e (Var r) \elim n
      | 0 => \case decideEq r l \as d \return if (decToBool d) e (Var r) = Var r \with {
        | yes e => absurd $ l/=r (inv e)
        | no n => idp
      }
      | suc n => \case decideEq l l \as d \return App (if {Expr} (decToBool d) e (Var l)) (replace (repeat n (Var l) (Var r)) l e) = App e (repeat n e (Var r)) \with {
        | yes e_ => pmap (App e) (left-neutral' {l} {r} {l/=r} n e)
        | no n => absurd $ n idp
      }

    \func right-neutral {l r : Nat} {l/=r : Not (l = r)} (n v : Nat) : replace (repeat n (Var l) (Var r)) r (Var v) = repeat n (Var l) (Var v)
      => right-neutral' {l} {r} {l/=r} n (Var v)

    \func right-neutral' {l r : Nat} {l/=r : Not (l = r)} (n : Nat) (e : Expr) : replace (repeat n (Var l) (Var r)) r e = repeat n (Var l) e \elim n
      | 0 => \case decideEq r r \as d \return if (decToBool d) e (Var r) = e \with {
        | yes e => idp
        | no n => absurd $ n idp
      }
      | suc n => \case decideEq l r \as d \return App (if {Expr} (decToBool d) e (Var l)) (replace (repeat n (Var l) (Var r)) r e) = App (Var l) (repeat n (Var l) e) \with {
        | yes e => absurd $ l/=r e
        | no n1 => pmap (App (Var l)) (right-neutral' {l} {r} {l/=r} n e)
      }
  }

\func numeral2 (n : Nat) : Expr => Lam 0 (Lam 1 (repeat n (Var 0) (Var 1)))
  \where {
    \func closed (n : Nat) : FV (numeral2 n) = nil \elim n
      | 0 => idp
      | suc n1 =>
        \let
          | r-fv => repeat.fx-onlyFreeVars {Var 0} {Var 1} n1
          | r-fv' => removeAll.monotone 0 (removeAll.monotone 1 (removeAll.monotone 0 (distinct.monotone (distinct.monotone r-fv))))
        \in
          leq.leqNil r-fv'
  }


\data Definable {T : \Type} {r : Repr T} {k : Nat} (f : K-Args-Fun T k) : \Set
  | def-exists (E : Expr) (\Pi (a : K-Args T k) -> Beta-Eq (K-App E <- map r a) (r (f <- a)))

\type NatDef {k : Nat} (f : K-Args-Fun Nat k) => Definable {Nat} {numeral2} {k} f

\func numbers-def (n : Nat) : NatDef {0} n
  | 0 => def-exists (numeral2 0) (\lam a => \case a \as a' \return Beta-Eq (Lam 0 (Lam 1 (Var 1)) <- map {Nat} {Expr} {0} numeral2 a') (numeral2 (0 <- a')) \with {
    | arg-empty => a-eq A-Eq2.ref
  })
  | suc n => def-exists (numeral2 (suc n)) (\lam a => \case a \as a' \return  Beta-Eq (Lam 0 (Lam 1 (App (Var 0) (repeat n (Var 0) (Var 1)))) <- map {Nat} {Expr} {0} numeral2 a') (numeral2 (suc n <- a')) \with {
    | arg-empty => a-eq A-Eq2.ref
  })

\func +-expr => Lam 0 $ Lam 1 $ Lam 2 $ Lam 3 $ App (App (Var 0) (Var 2)) (App (App (Var 1) (Var 2)) (Var 3))
\func +-def : NatDef {2} (Nat.+) =>
  def-exists +-expr (\lam (arg-con a1 (arg-con a2 arg-empty) : K-Args Nat 2) => \case a1 \as a, a2 \as b \return Beta-Eq (App (App +-expr (numeral2 a)) (numeral2 b))
                      (numeral2 (a Nat.+ b)) \with {
    | 0, 0 => chain (App (Lam 1 $ Lam 2 $ Lam 3 $ App (App (numeral2 0) (Var 2)) (App (App (Var 1) (Var 2)) (Var 3))) (numeral2 0))
        (one-step-left (beta-app-right (beta-repl-right idp) A-Eq2.ref))
        (chain (Lam 2 $ Lam 3 $ App (App (numeral2 0) (Var 2)) (App (App (numeral2 0) (Var 2)) (Var 3)))
            (one-step-left (beta-repl-right idp))
            (chain (Lam 2 $ Lam 3 $ App (Lam 1 (Var 1)) (App (App (numeral2 0) (Var 2)) (Var 3)))
                (one-step-left (bred-lam idp (bred-lam idp (beta-app-right (beta-repl-right idp) A-Eq2.ref))))
                (chain (Lam 2 $ Lam 3 (App (App (numeral2 0) (Var 2)) (Var 3)))
                    (one-step-left (bred-lam idp (bred-lam idp (beta-repl-right idp))))
                    (chain (Lam 2 $ Lam 3 (App (Lam 1 (Var 1)) (Var 3)))
                        (one-step-left (bred-lam idp (bred-lam idp (beta-app-right (beta-repl-right idp) A-Eq2.ref))))
                        (chain (Lam 2 $ Lam 3 (Var 3))
                            (one-step-left (bred-lam idp (bred-lam idp (beta-repl-right idp))))
                            (a-eq (A-Eq2.a2lam-eq (A-Eq2.a2lam-eq (a2var-eq idp))))
                        )
                    )
                )
            )
        )
    | 0, suc b => chain (App (Lam 1 $ Lam 2 $ Lam 3 $ App (App (numeral2 0) (Var 2)) (App (App (Var 1) (Var 2)) (Var 3))) (numeral2 $ suc b))
        (one-step-left (beta-app-right (beta-repl-right idp) A-Eq2.ref))
        (chain (Lam 2 $ Lam 3 $ App (App (numeral2 0) (Var 2)) (App (App (numeral2 (suc b)) (Var 2)) (Var 3)))
            (one-step-left (beta-repl-right idp))
            (chain (Lam 2 $ Lam 3 $ App (Lam 1 (Var 1)) (App (App (numeral2 (suc b)) (Var 2)) (Var 3)))
                (one-step-left (bred-lam idp (bred-lam idp (beta-app-right (beta-repl-right idp) A-Eq2.ref))))
                (chain (Lam 2 $ Lam 3 (App (App (numeral2 (suc b)) (Var 2)) (Var 3)))
                    (one-step-left (bred-lam idp (bred-lam idp (beta-repl-right idp))))
                    (chain (Lam 2 $ Lam 3 (App (Lam 1 (repeat (suc b) (Var 2) (Var 1))) (Var 3)))
                        (one-step-left (bred-lam idp (bred-lam idp (beta-app-right (beta-repl-right (pmap (\lam x => Lam 1 (App (Var 2) x)) (inv (repeat.left-neutral {0} {1} {\lam p => suc/=0 (inv p)} b 2)))) A-Eq2.ref))))
                        (chain (Lam 2 $ Lam 3 (repeat (suc b) (Var 2) (Var 3)))
                            (one-step-left (bred-lam idp (bred-lam idp (beta-repl-right (pmap (\lam x => App (Var 2) x) (inv $ repeat.right-neutral {2} {1} {\lam p => suc/=0 (pmap pred p)} b 3))))))
                            (a-eq $ +-def-lemma1 b)
                        )
                    )
                )
            )
        )
    | suc a, 0 => chain (App (Lam 1 $ Lam 2 $ Lam 3 $ App (App (numeral2 $ suc a) (Var 2)) (App (App (Var 1) (Var 2)) (Var 3))) (numeral2 $ 0))
        (one-step-left (beta-app-right (beta-repl-right idp) A-Eq2.ref))
        (chain (Lam 2 $ Lam 3 $ App (App (numeral2 $ suc a) (Var 2)) (App (App (numeral2 0) (Var 2)) (Var 3)))
            (one-step-left (beta-repl-right idp))
            (chain (Lam 2 $ Lam 3 $ App (App (numeral2 $ suc a) (Var 2)) (Var 3))
                (chain (Lam 2 $ Lam 3 $ App (App (numeral2 $ suc a) (Var 2)) (App (Lam 1 (Var 1)) (Var 3)))
                    (one-step-left (bred-lam idp (bred-lam idp (beta-app-left A-Eq2.ref (beta-app-right (beta-repl-right idp) A-Eq2.ref)))))
                    (chain (Lam 2 $ Lam 3 $ App (App (numeral2 $ suc a) (Var 2)) (Var 3))
                        (one-step-left (bred-lam idp (bred-lam idp (beta-app-left A-Eq2.ref (beta-repl-right idp)))))
                        (a-eq A-Eq2.ref)
                    )
                )
                (chain (Lam 2 $ Lam 3 (App (App (numeral2 (suc a)) (Var 2)) (Var 3)))
                    (a-eq A-Eq2.ref)
                    (chain (Lam 2 $ Lam 3 (App (Lam 1 (repeat (suc a) (Var 2) (Var 1))) (Var 3)))
                        (one-step-left (bred-lam idp (bred-lam idp (beta-app-right (beta-repl-right (pmap (\lam x => Lam 1 (App (Var 2) x)) (inv (repeat.left-neutral {0} {1} {\lam p => suc/=0 (inv p)} a 2)))) A-Eq2.ref))))
                        (chain (Lam 2 $ Lam 3 (repeat (suc a) (Var 2) (Var 3)))
                            (one-step-left (bred-lam idp (bred-lam idp (beta-repl-right (pmap (\lam x => App (Var 2) x) (inv $ repeat.right-neutral {2} {1} {\lam p => suc/=0 (pmap pred p)} a 3))))))
                            (a-eq $ +-def-lemma1 a)
                        )
                    )
                )
            )
        )
    | suc a, suc b => chain (App (Lam 1 $ Lam 2 $ Lam 3 $ App (App (numeral2 $ suc a) (Var 2)) (App (App (Var 1) (Var 2)) (Var 3))) (numeral2 $ suc b))
        (one-step-left (beta-app-right (beta-repl-right idp) A-Eq2.ref))
        (chain (Lam 2 $ Lam 3 $ App (App (numeral2 $ suc a) (Var 2)) (App (App (numeral2 (suc b)) (Var 2)) (Var 3)))
            (one-step-left (beta-repl-right idp))
            (chain (Lam 2 $ Lam 3 $ App (Lam 1 $ repeat (suc a) (Var 2) (Var 1)) (App (App (numeral2 (suc b)) (Var 2)) (Var 3)))
                (one-step-left (bred-lam idp (bred-lam idp (beta-app-right (beta-repl-right (pmap (Lam 1) (inv $ repeat.left-neutral {0} {1} {\lam p => suc/=0 (inv p)} (suc a) 2))) A-Eq2.ref))))
                (chain (Lam 2 $ Lam 3 $ App (Lam 1 $ repeat (suc a) (Var 2) (Var 1)) (App (Lam 1 $ repeat (suc b) (Var 2) (Var 1)) (Var 3)))
                    (one-step-left (bred-lam idp (bred-lam idp (beta-app-left A-Eq2.ref (beta-app-right (beta-repl-right (pmap (\lam x => Lam 1 (App (Var 2) x)) (inv $ repeat.left-neutral {0} {1} {\lam p => suc/=0 (inv p)} b 2))) A-Eq2.ref)))))
                    (chain (Lam 2 $ Lam 3 $ App (Lam 1 $ repeat (suc a) (Var 2) (Var 1)) (repeat (suc b) (Var 2) (Var 3)))
                        (one-step-left (bred-lam idp (bred-lam idp (beta-app-left A-Eq2.ref (beta-repl-right (pmap (App (Var 2)) (inv $ repeat.right-neutral {2} {1} {\lam p => suc/=0 (pmap pred p)} b 3)))))))
                        (chain (Lam 2 $ Lam 3 $ repeat (suc a) (Var 2) (repeat (suc b) (Var 2) (Var 3)))
                            (one-step-left (bred-lam idp (bred-lam idp (beta-repl-right (pmap (App (Var 2)) (inv $ repeat.right-neutral' {2} {1} {\lam p => suc/=0 (pmap pred p)} a (repeat (suc b) (Var 2) (Var 3))))))))
                            (a-eq (+-def-lemma3 a b))
                        )
                    )
                )
            )
        )
  })
  \where {
    \func +-def-lemma1 (b : Nat) : A-Eq (Lam 2 (Lam 3 (App (Var 2) (repeat b (Var 2) (Var 3))))) (numeral2 (suc b)) \elim b
      | 0 => A-Eq2.a2lam-eq (A-Eq2.a2lam-eq (a2app-eq (a2var-eq idp) (a2var-eq idp)))
      | suc b => (A-Eq2.a2lam-eq (A-Eq2.a2lam-eq (a2app-eq (a2var-eq idp) (a2app-eq (a2var-eq idp) (+-def-lemma1-lemma b)))) : A-Eq (Lam 2 (Lam 3 (App (Var 2) (repeat (suc b) (Var 2) (Var 3))))) (Lam 0 (Lam 1 (App (Var 0) (repeat (suc b) (Var 0) (Var 1))))))
      \where {
        \func +-def-lemma1-lemma {n : Nat} (b : Nat) : A-Eq2 (repeat b (Var 2) (Var 3)) (repeat b (Var 0) (Var 1))
            (A-Eq2.extMod (A-Eq2.extMod idNat 2 (common-new-var-no (Lam 3 (App (Var 2) (App (Var 2) (repeat n (Var 2) (Var 3)))))
                (Lam 1 (App (Var 0) (App (Var 0) (repeat n (Var 0) (Var 1))))) idNat idNat)) 3 (common-new-var-no
                (App (Var 2) (App (Var 2) (repeat n (Var 2) (Var 3)))) (App (Var 0) (App (Var 0) (repeat n (Var 0) (Var 1))))
                (A-Eq2.extMod idNat 2 (common-new-var-no (Lam 3 (App (Var 2) (App (Var 2) (repeat n (Var 2) (Var 3)))))
                    (Lam 1 (App (Var 0) (App (Var 0) (repeat n (Var 0) (Var 1))))) idNat idNat))
                (A-Eq2.extMod idNat 0 (common-new-var-no (Lam 3 (App (Var 2) (App (Var 2) (repeat n (Var 2) (Var 3)))))
                    (Lam 1 (App (Var 0) (App (Var 0) (repeat n (Var 0) (Var 1))))) idNat idNat))))
            (A-Eq2.extMod (A-Eq2.extMod idNat 0 (common-new-var-no (Lam 3 (App (Var 2) (App (Var 2) (repeat n (Var 2) (Var 3)))))
                (Lam 1 (App (Var 0) (App (Var 0) (repeat n (Var 0) (Var 1))))) idNat idNat)) 1 (common-new-var-no
                (App (Var 2) (App (Var 2) (repeat n (Var 2) (Var 3)))) (App (Var 0) (App (Var 0) (repeat n (Var 0) (Var 1))))
                (A-Eq2.extMod idNat 2 (common-new-var-no (Lam 3 (App (Var 2) (App (Var 2) (repeat n (Var 2) (Var 3)))))
                    (Lam 1 (App (Var 0) (App (Var 0) (repeat n (Var 0) (Var 1))))) idNat idNat))
                (A-Eq2.extMod idNat 0 (common-new-var-no (Lam 3 (App (Var 2) (App (Var 2) (repeat n (Var 2) (Var 3)))))
                    (Lam 1 (App (Var 0) (App (Var 0) (repeat n (Var 0) (Var 1))))) idNat idNat)))) \elim b
          | 0 => a2var-eq idp
          | suc b => a2app-eq (a2var-eq idp) (+-def-lemma1-lemma b)
      }

    \func +-def-lemma3 (a b : Nat) : A-Eq (Lam 2 (Lam 3 (App (Var 2) (repeat a (Var 2) (App (Var 2) (repeat b (Var 2) (Var 3)))))))
        (numeral2 (suc (suc (a Nat.+ b)))) =>
          rewrite (repeat.repeat-linear-+ {Var 2} {Var 3} (a Nat.+ 1) (b Nat.+ 1)) (A-Eq2.a2lam-eq (A-Eq2.a2lam-eq (+-def-lemma4 {2} {3} {0} {1} {\lam p => suc/=0 (pmap (\lam x => pred (pred x)) (inv p))} {\lam p => suc/=0 (inv p)} (suc (suc (a Nat.+ b))))))

    \func +-def-lemma4 {x0 y0 x1 y1 : Nat} {p0 : Not (x0 = y0)} {p1 : Not (x1 = y1)} {t0 t1 : Nat} (n : Nat) : A-Eq2 (repeat n (Var x0) (Var y0)) (repeat n (Var x1) (Var y1)) (A-Eq2.extMod (A-Eq2.extMod idNat x0 t0) y0 t1) (A-Eq2.extMod (A-Eq2.extMod idNat x1 t0) y1 t1) \elim n
      | 0 => a2var-eq (\case decideEq y0 y0 \as d0, decideEq y1 y1 \as d1 \return if (decToBool d0) t1 (A-Eq2.extMod idNat x0 t0 y0) = if (decToBool d1) t1 (A-Eq2.extMod idNat x1 t0 y1) \with {
        | yes e, yes e1 => idp
        | yes e, no n => absurd (n idp)
        | no n, yes e => absurd (n idp)
        | no n, no n1 => absurd (n idp)
      })
      | suc n => a2app-eq (a2var-eq (\case decideEq x0 y0 \as d0, decideEq x1 y1 \as d1 \return if (decToBool d0) t1 (A-Eq2.extMod idNat x0 t0 x0) = if (decToBool d1) t1 (A-Eq2.extMod idNat x1 t0 x1) \with {
        | yes e, yes e1 => idp
        | yes e, no n => absurd (p0 e)
        | no n, yes e => absurd (p1 e)
        | no n, no n1 => \case decideEq x0 x0 \as d0, decideEq x1 x1 \as d1 \return if (decToBool d0) t0 x0 = if (decToBool d1) t0 x1 \with {
          | yes e, yes e1 => idp
          | yes e, no n2 => absurd (n2 idp)
          | no n2, yes e => absurd (n2 idp)
          | no n2, no n3 => absurd (n2 idp)
        }
      })) (+-def-lemma4 {x0} {y0} {x1} {y1} {p0} {p1} {t0} {t1}  n)
  }

\func *-expr => Lam 0 (Lam 1 (Lam 2 (App (Var 0) (App (Var 1) (Var 2)))))
\func *-def : NatDef {2} (Nat.*) =>
  def-exists *-expr
      (\lam (arg-con a1 (arg-con a2 arg-empty) : K-Args Nat 2) => \case a1 \as a, a2 \as b \return Beta-Eq (App (App (Lam 0 (Lam 1 (Lam 2 (App (Var 0) (App (Var 1) (Var 2)))))) (numeral2 a)) (numeral2 b))
          (numeral2 (a Nat.* b)) \with {
        | 0, 0 => chain
                    (App (Lam 1 (Lam 2 (App (numeral2 0) (App (Var 1) (Var 2))))) (numeral2 0))
                    (one-step-left (beta-app-right (beta-repl-right idp) A-Eq2.ref))
                    (chain
                        (Lam 2 (App (numeral2 0) (App (numeral2 0) (Var 2))))
                        (one-step-left (beta-repl-right idp))
                        (chain
                            (Lam 2 (Lam 1 (Var 1)))
                            (one-step-left (bred-lam idp (beta-repl-right idp)))
                            (a-eq (A-Eq2.a2lam-eq (A-Eq2.a2lam-eq (a2var-eq idp))))
                        )
                    )
        | 0, suc n => chain
                        (App (Lam 1 (Lam 2 (App (numeral2 0) (App (Var 1) (Var 2))))) (numeral2 (suc n)))
                        (one-step-left (beta-app-right (beta-repl-right idp) A-Eq2.ref))
                        (chain
                            (Lam 2 (App (numeral2 0) (App (numeral2 (suc n)) (Var 2))))
                            (one-step-left (beta-repl-right idp))
                            (chain
                                (Lam 2 (Lam 1 (Var 1)))
                                (one-step-left (bred-lam idp (beta-repl-right idp)))
                                (a-eq (A-Eq2.a2lam-eq (A-Eq2.a2lam-eq (rewrite (NatSemiring.zro_*-left {n}) (a2var-eq idp)))))
                            )
                        )
        | suc n, 0 => chain
                        (App (Lam 1 (Lam 2 (App (numeral2 (suc n)) (App (Var 1) (Var 2))))) (numeral2 0))
                        (one-step-left (beta-app-right (beta-repl-right idp) A-Eq2.ref))
                        (chain
                            (Lam 2 (App (numeral2 (suc n)) (App (numeral2 0) (Var 2))))
                            (one-step-left (beta-repl-right idp))
                            (chain
                                (Lam 2 (App (numeral2 (suc n)) (Lam 1 (Var 1))))
                                (one-step-left (bred-lam idp (beta-app-left A-Eq2.ref (beta-repl-right idp))))
                                (chain
                                    (Lam 2 (Lam 1 (Var 1)))
                                    (neutral-numeral2 {suc n})
                                    (a-eq (A-Eq2.a2lam-eq (A-Eq2.a2lam-eq (a2var-eq idp))))
                                )
                            )
        )
        | suc n, suc m => chain
                            (App (Lam 1 (Lam 2 (App (numeral2 (suc n)) (App (Var 1) (Var 2))))) (numeral2 (suc m)))
                            (one-step-left (beta-app-right (beta-repl-right idp) A-Eq2.ref))
                            (chain
                                (Lam 2 (App (numeral2 (suc n)) (App (numeral2 (suc m)) (Var 2))))
                                (one-step-left (beta-repl-right idp))
                                (chain
                                    (Lam 2 (App (numeral2 (suc n)) (Lam 1 $ repeat (suc m) (Var 2) (Var 1))))
                                    (one-step-left (bred-lam idp (beta-app-left A-Eq2.ref (beta-repl-right (pmap (\lam x => Lam 1 (App (Var 2) x)) (inv (repeat.left-neutral {0} {1} {\lam p => suc/=0 (inv p)} m 2)))))))
                                    (chain
                                        (Lam 2 (Lam 1 $ repeat (suc n) (Lam 1 $ repeat (suc m) (Var 2) (Var 1)) (Var 1)))
                                        (one-step-left (bred-lam idp (beta-repl-right (pmap (\lam x => Lam 1 (App (Lam 1 (App (Var 2) (repeat m (Var 2) (Var 1)))) x)) (inv (repeat.left-neutral' {0} {1} {\lam p => suc/=0 (inv p)} n (Lam 1 (App (Var 2) (repeat m (Var 2) (Var 1))))))))))
                                        (chain
                                            (Lam 2 (Lam 1 $ repeat (suc n * suc m) (Var 2) (Var 1)))
                                            (*-def-lemma m n)
                                            {?}
                                        )
                                    )
                                )
                            )
      })
  \where {
    \func neutral-numeral2 {n : Nat} : Beta-Eq (Lam 2 (App (numeral2 n) (Lam 1 (Var 1)))) (Lam 2 (Lam 1 (Var 1)))
      | {0} => chain (Lam 2 (Lam 1 (Var 1))) (one-step-left (bred-lam idp (beta-repl-right idp))) (a-eq (A-Eq2.a2lam-eq (A-Eq2.a2lam-eq (a2var-eq idp))))
      | {suc n} =>
        \let
          | rec => neutral-numeral2 {n}
          | repl => replace-repeat {suc n} {Lam 1 (Var 1)}
        \in chain
            (Lam 2 $ Lam 1 $ repeat (suc n) (Lam 1 (Var 1)) (Var 1))
            (one-step-left (bred-lam idp (beta-repl-right (pmap (Lam 1) repl))))
            (chain
                (Lam 2 $ Lam 1 (repeat n (Lam 1 (Var 1)) (Var 1)))
                (one-step-left (bred-lam idp (bred-lam idp (beta-repl-right idp))))
                (r-chain
                    (Lam 2 $ App (Lam 0 (Lam 1 (repeat n (Var 0) (Var 1)))) (Lam 1 (Var 1)))
                    (one-step-left (bred-lam idp (beta-repl-right (pmap (Lam 1) (replace-repeat {n} {Lam 1 (Var 1)})))))
                    rec
                )
            )

    \func replace-repeat {n : Nat} {x : Expr} : repeat n x (Var 1) = replace (repeat n (Var 0) (Var 1)) 0 x \elim n
      | 0 => idp
      | suc n => \let rec => replace-repeat {n} {x} \in pmap (App x) rec

    \func lam-eq {n : Nat} {B1 B2 : Expr} (b-eq : Beta-Eq B1 B2) : Beta-Eq (Lam n B1) (Lam n B2) \elim b-eq
      | a-eq a => a-eq (A-Eq2.a2lam-eq (lam-eq-lemma B1 B2 n a))
      | one-step-left b => one-step-left (bred-lam idp b)
      | one-step-right b => one-step-right (bred-lam idp b)
      | chain tmp b-eq1 b-eq2 => chain (Lam n tmp) (lam-eq b-eq1) (lam-eq b-eq2)
      | r-chain tmp b-eq1 b-eq2 => r-chain (Lam n tmp) (lam-eq b-eq1) (lam-eq b-eq2)
      \where {
        \func lam-eq-lemma (B1 B2 : Expr) (n : Nat) (a : A-Eq B1 B2) :
          A-Eq2 B1 B2 (A-Eq2.extMod idNat n (common-new-var-no B1 B2 idNat idNat)) (A-Eq2.extMod idNat n (common-new-var-no B1 B2 idNat idNat)) =>
          \let
            | idNat=extNN : A-Eq2.extMod idNat n n = idNat => feq {A-Eq2.extMod idNat n n} {idNat}
                (\lam e => \case decideEq e n \as d \return if (decToBool d) n (idNat e) = idNat e \with {
                  | yes e1 => inv e1
                  | no n1 => idp
                })
            | a' => rewriteF (inv idNat=extNN) (a : A-Eq2 B1 B2 idNat idNat)
          \in \case NatSemiring.trichotomy n (common-new-var-no B1 B2 idNat idNat) \with {
            | less _x => \let <=x => <_suc_<= (NatSemiring.<-transitive _x id<suc) \in {?} -- A-Eq2.trans.upper {B1} {B2} {n} {n} {idNat} {idNat} {n} {common-new-var-no B1 B2 idNat idNat} {{?}} {{?}} a' <=x
            | equals p => rewriteF (pmap (\lam x => A-Eq2.extMod idNat n x) p) a'
            | greater _x => {?}
          }
      }

    \func *-def-lemma (m n : Nat) :
      Beta-Eq
          (Lam 2 (Lam 1 (repeat (suc n) (Lam 1 (repeat (suc m) (Var 2) (Var 1))) (Var 1))))
          (Lam 2 (Lam 1 (repeat (suc n * suc m) (Var 2) (Var 1)))) \elim m, n
      | 0, 0 => one-step-left (bred-lam idp (bred-lam idp (beta-repl-right idp)))
      | 0, suc n => {?}
      | suc m, 0 => {?}
      | suc m, suc n => {?}
  }

\func apply-first-lambda (e : Expr) : Maybe Expr \elim e
  | Con n => nothing
  | Var n => nothing
  | Lam n e => mapMaybe (Lam n) (apply-first-lambda e)
  | App e1 e2 => \case e1 \with {
    | Lam n e => just (replace e n e2)
    | _ => \case apply-first-lambda e1 \with {
      | nothing => mapMaybe (App e1) (apply-first-lambda e2)
      | just a => just (App a e2)
    }
  }

\func mapMaybe {A B : \Type} (f : A -> B) (ma : Maybe A) : Maybe B \elim ma
  | nothing => nothing
  | just a => just (f a)

\func feq {f g : Nat -> Nat} (p : \Pi (e : Nat) -> f e = g e) : f = g => path (\lam i n => p n @ i)