\import Paths
\import calculus.Base

\data BetaRed (e1 e2 : Expr_) \elim e1, e2
  | P1 @ Q1, P2 @ Q2 => bred-app-right (P1 = P2) (BetaRed Q1 Q2)
  | P1 @ Q1, P2 @ Q2 => bred-app-left (BetaRed P1 P2) (Q1 = Q2)
  | (l P) @ Q, s => bred-repl (s = apply_ P Q)
  | l B1, l B2 => bred-lam (BetaRed B1 B2)

\data BetaChain (e1 e2 : Expr_)
  | b-chain-end (e1 = e2)
  | b-chain-con (tmp : Expr_) (BetaRed e1 tmp) (BetaChain tmp e2)

\data BetaEq (e1 e2 : Expr_)
  | b-eq-eq (e1 = e2)
  | b-eq-red (BetaRed e1 e2)
  | b-eq-inv-red (BetaRed e2 e1)
  | b-eq-chain (tmp : Expr_) (BetaEq e1 tmp) (BetaEq tmp e2)
  \where {
    \func sym {e1 e2 : Expr_} (p : BetaEq e1 e2) : BetaEq e2 e1 \elim p
      | b-eq-eq p => b-eq-eq (inv p)
      | b-eq-red b => b-eq-inv-red b
      | b-eq-inv-red b => b-eq-red b
      | b-eq-chain tmp p1 p2 => b-eq-chain tmp (sym p2) (sym p1)

    \func app-save-eq-left {P1 P2 Q : Expr_} (b-p : BetaEq P1 P2) : BetaEq (P1 @ Q) (P2 @ Q) \elim b-p
      | b-eq-eq p => b-eq-eq (pmap2 (@) p idp)
      | b-eq-red b => b-eq-red (bred-app-left b idp)
      | b-eq-inv-red b => b-eq-inv-red (bred-app-left b idp)
      | b-eq-chain tmp b-p1 b-p2 => b-eq-chain (tmp @ Q) (app-save-eq-left b-p1) (app-save-eq-left b-p2)

    \func app-save-eq-right {P Q1 Q2 : Expr_} (b-q : BetaEq Q1 Q2) : BetaEq (P @ Q1) (P @ Q2) \elim b-q
      | b-eq-eq p => b-eq-eq (pmap2 (@) idp p)
      | b-eq-red b => b-eq-red (bred-app-right idp b)
      | b-eq-inv-red b => b-eq-inv-red (bred-app-right idp b)
      | b-eq-chain tmp b-p1 b-p2 => b-eq-chain (P @ tmp) (app-save-eq-right b-p1) (app-save-eq-right b-p2)

    \func lam-save-eq {B1 B2 : Expr_} (b-q : BetaEq B1 B2) : BetaEq (l B1) (l B2) \elim b-q
      | b-eq-eq p => b-eq-eq (pmap l p)
      | b-eq-red b => b-eq-red (bred-lam b)
      | b-eq-inv-red b => b-eq-inv-red (bred-lam b)
      | b-eq-chain tmp b-q1 b-q2 => b-eq-chain (l tmp) (lam-save-eq b-q1) (lam-save-eq b-q2)
  }