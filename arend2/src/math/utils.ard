\import Arith.Nat
\import Data.Bool
\import Data.Or
\import Function.Meta
\import Logic
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta

\func max (a b : Nat) : Nat \elim a, b
  | 0, 0 => 0
  | 0, suc b1 => suc b1
  | suc a1, 0 => suc a1
  | suc a1, suc b1 => suc (max a1 b1)
  \where {
    \func max-0-0 : max 0 0 = 0 => \case max 0 0 \with {
      | 0 => idp
      | suc n => idp
    }
    \func max-sym (a b : Nat) : max a b = max b a \elim a, b
      | 0, 0 => idp
      | 0, suc b => idp
      | suc a, 0 => idp
      | suc a, suc b => pmap suc (max-sym a b)
    -- жесть осознал вещи
    \func a<=b->max=b (a b : Nat) (p : a <= b) : max a b = b \elim a, b
      | 0, 0 => max-0-0
      | 0, suc b => idp
      | suc a, 0 => absurd (suc/=0 (<=-antisymmetric p (zero<=_ {suc a})))
      | suc a, suc b => pmap suc (a<=b->max=b a b (suc<=suc.conv p))

    \func maxa_b=avb {a b : Nat} : (max a b = a) || (max a b = b) =>
      \case NatSemiring.totality a b \with {
        | byLeft a<=b => byRight (a<=b->max=b a b a<=b)
        | byRight b<=a => byLeft (rewriteF (max-sym b a) (a<=b->max=b b a b<=a))
      }

    \func a_b<=max {a b : Nat} : \Sigma (a <= max a b) (b <= max a b) =>
      \case NatSemiring.totality a b \with {
        | byLeft a<=b => \let
          | b_<=_max_a_b => NatSemiring.<=_= (inv (a<=b->max=b a b a<=b))
                         \in (<=∘ a<=b b_<=_max_a_b, b_<=_max_a_b)
        | byRight b<=a => \let
          | a_<=_max_b_a => NatSemiring.<=_= (inv (a<=b->max=b b a b<=a))
          | a_<=_max_a_b => <=∘ a_<=_max_b_a (NatSemiring.<=_= (max-sym b a))
                          \in (a_<=_max_a_b , <=∘ b<=a a_<=_max_a_b )
      }
    \func max-monotone {a b a' b' : Nat} (a<a' : a < a') (b<b' : b < b') : max a b < max a' b' =>
      \case totality a b \with {
        | byLeft a<=b => <=-<-transitive
            (NatSemiring.<=_= (a<=b->max=b a b a<=b))
            (<-<=-transitive b<b' (a_b<=max {a'} {b'}).2)
        | byRight b<=a =>
          rewrite (max-sym a' b') $
          rewrite (max-sym a b) $
            <=-<-transitive
              (NatSemiring.<=_= (a<=b->max=b b a b<=a))
              (<-<=-transitive a<a' (a_b<=max {b'} {a'}).2)
      }
  }

\func <-<=-transitive {a b c : Nat} (a<b : a < b) (b<=c : b <= c) : a < c =>
  \case LinearOrder.<=-dec b<=c \with {
    | inl b<c => NatSemiring.<-transitive a<b b<c
    | inr b=c => rewriteF b=c a<b
  }

\func <=-<-transitive {a b c : Nat} (a<=b : a <= b) (b<c : b < c) : a < c =>
  \case LinearOrder.<=-dec a<=b \with {
    | inl a<b => NatSemiring.<-transitive a<b b<c
    | inr a=b => rewriteF (inv a=b) b<c
  }

\func split-max {c a b : Nat} (p : c = max a b) : (c = a) || (c = b) =>
  \case max.maxa_b=avb {a} {b} \with {
    | byLeft max=a => byLeft (p *> max=a)
    | byRight max=b => byRight (p *> max=b)
  }

\func if-left {A : \Type}  (a b : A) : if true a b = a => idp
\func if-right {A : \Type} (a b : A) : if false a b = b => idp
